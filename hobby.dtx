% \iffalse meta-comment
%<*internal>
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
Copyright (C) 2012 by Andrew Stacey
-------------------------------------------

This file may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at
 your option) any later version.
The latest version of this license is in:

   http://www.latex-project.org/lppl.txt

and version 1.3 or later is part of all distributions of LaTeX
version 2005/12/01 or later.
\endpreamble
\generate{\file{tikzlibraryhobby.code.tex} {\from{hobby.dtx}{tikzlibrary}}}
\generate{\file{pgflibraryhobby.code.tex} {\from{hobby.dtx}{pgflibrary}}}
\generate{\file{hobby.code.tex}
{\from{hobby.dtx}{hobby}}}
%</install>
%<install>\endbatchfile
%<*internal>
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass{l3doc}
\usepackage[T1]{fontenc}
\usepackage{csquotes}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{amsmath}
\usetikzlibrary{hobby,decorations.pathreplacing}
\usepackage[margin=3cm]{geometry}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\tikzset{
  shape example/.style={
    color=black!30,
    draw,
    fill=yellow!30,
    line width=.5cm,
    inner xsep=2.5cm,
    inner ysep=0.5cm}
}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{Hobby's Algorithm in TikZ/PGF}
% \author{Andrew Stacey}
% \date{2012-05-15}
% \maketitle
%
% 
% \section{Usage}
%
% The package is provided in form of a PGF library.
% It can be loaded with
%\begin{verbatim}
%\usetikzlibrary{hobby}
%\end{verbatim}
% or
%\begin{verbatim}
%\usepgflibrary{hobby}
%\end{verbatim}
% or the equivalent ConTeXt commands.
%
% The TikZ library installs a \Verb+to path+ which draws a smooth curve through the given points.
% \tikzset{
%   show curve controls/.style={
%    decoration={
%      show path construction,
%      curveto code={
%      \draw [blue, dashed]
%          (\tikzinputsegmentfirst)    -- (\tikzinputsegmentsupporta)
%          node [at end, draw, solid, red, inner sep=2pt]{};
%        \draw [blue, dashed]
%          (\tikzinputsegmentsupportb) -- (\tikzinputsegmentlast)
%          node [at start, draw, solid, red, inner sep=2pt]{};
%      }
%    },decorate
%  },
% }
%
% \begin{tikzpicture}
% \draw[scale=.1,postaction=show curve controls,line width=1mm,red] (0,0)
% .. controls (26.76463,-1.84543) and (51.4094,14.58441) .. (60,40)
% .. controls (67.09875,61.00188) and (59.76253,84.57518) .. (40,90)
% .. controls (25.35715,94.01947) and (10.48064,84.5022) .. (10,70)
% .. controls (9.62895,58.80421) and (18.80421,49.62895) .. (30,50);
% 
% \fill[green] (0,0) circle[radius=2pt]
%  (6,4) circle[radius=2pt]
%  (4,9) circle[radius=2pt]
%  (1,7) circle[radius=2pt]
%  (3,5) circle[radius=2pt];
% \draw[postaction=show curve controls,thick] (0,0) to[curve through={(6,4) .. (4,9) .. (1,7)}] (3,5);
% 
% \end{tikzpicture}
% 
% \begin{tikzpicture}
% \draw[scale=.1,postaction=show curve controls,line width=1mm,red] (0,0)
% .. controls (5.18756,-26.8353) and (60.36073,-18.40036) .. (60,40)
% .. controls (59.87714,59.889) and (57.33896,81.64203) .. (40,90)
% .. controls (22.39987,98.48387) and (4.72404,84.46368) .. (10,70)
% .. controls (13.38637,60.7165) and (26.35591,59.1351) .. (30,50)
% .. controls (39.19409,26.95198) and (-4.10555,21.23804) .. (0,0); % 
% \fill[green] (0,0) circle[radius=2pt]
%  (6,4) circle[radius=2pt]
%  (4,9) circle[radius=2pt]
%  (1,7) circle[radius=2pt]
%  (3,5) circle[radius=2pt];
% \draw[postaction=show curve controls,thick] (0,0) to[closed,curve through={(6,4) .. (4,9) .. (1,7)}] (3,5);
% 
% \end{tikzpicture}
% 
% \section{Implementing Hobby's Algorithm}
% 
% We start with a list of \(n+1\) points, \(z_0, \dotsc, z_n\).
% The base code assumes that these are already stored in two property lists: the \(x\)--coordinates in \Verb+\l_hobby_pointsx_prop+ and the \(y\)--coordinates in \Verb+\l_hobby_pointsy_prop+.
% As our arrays are \(0\)--indexed, the actual number of points is one more than this.
% For a closed curve, we have \(z_n = z_0\)\footnote{Note that there is a difference between a closed curve and an open curve whose endpoints happen to overlap}.
% For closed curves it will be convenient to add an additional point at \(z_1\): thus \(z_{n+1} = z_1\).
% This makes \(z_n\) an internal point and makes the algorithms for closed paths and open paths agree longer than they would otherwise.
% The number of apparent points is stored as \Verb+\l_hobby_npoints_int+.
% Thus for an open path, \Verb+\l_hobby_npoints_int+ is \(n\), whilst for a closed path, it is \(n+1\)\footnote{In fact, we allow for the case where the user specifies a closed path but with \(z_n \ne z_0\).
% In that case, we assume that the user meant to repeat \(z_0\).
% This adds another point to the list.}.
% Following Hobby, let us write \(n'\) for \(n\) if the path is open and \(n+1\) if closed.
%
% From this we compute the distances and angles between successive points, storing these again as property lists.
% These are \Verb+\l_hobby_distances_prop+ and \Verb+\l_hobby_angles_prop+.
% The term indexed by \(k\) is the distance (or angle) of the line between the \(k\)th point and the \(k+1\)th point.
% For the internal nodes\footnote{Hobby calls the specified points \emph{knots}}, we store the difference in the angles in \Verb+\l_hobby_psi_prop+.
% The \(k\)th value on this is the angle subtended at the \(k\)th node.
% This is thus indexed from \(1\) to \(n'-1\).
% 
% The bulk of the work consists in setting up a linear system to compute the angles of the control points.
% At a node, say \(z_i\), we have various pieces of information:
%
% \begin{enumerate}
% \item The angle of the incoming curve, \(\phi_i\), relative to the straight line from \(z_{i-1}\) to \(z_i\)
% \item The angle of the outgoing curve, \(\theta_i\), relative to the straight line from \(z_i\) to \(z_{i+1}\)
% \item The tension of the incoming curve, \(\overline{\tau}_i\)
% \item The tension of the outgoing curve, \(\tau_i\)
% \item The speed of the incoming curve, \(\sigma_i\)
% \item The speed of the outgoing curve, \(\rho_i\)
% \end{enumerate}
%
% The tensions are known at the start.
% The speeds are computed from the angles.
% Thus the key thing to compute is the angles.
% This is done by imposing a ``mock curvature'' condition.%
% The formula for the mock curvature is:
%^^A
% \[
%   \hat{k}(\theta,\phi,\tau,\overline{\tau}) = \tau^2 \left( \frac{2(\theta + \phi)}{\overline{\tau}} - 6\theta\right)
% \]
%^^A
% and the condition that the mock curvatures have to satisfy is that at each \emph{internal} node, the curvatures must match:
% %
% \[
%   \hat{k}(\phi_i,\theta_{i-1},\overline{\tau}_i,\tau_{i-1})/d_{i-1} = \hat{k}(\theta_i,\phi_{i+1},\tau_i,\overline{\tau}_{i+1})/d_i.
% \]
%^^A
% Substituting in yields:
%^^A
% \[
%   \frac{\overline{\tau}_i^2}{d_{i-1}} \left( \frac{2(\phi_i + \theta_{i-1})}{\tau_{i-1}} - 6\phi_i\right) = \frac{\tau_i^2}{d_i} \left( \frac{2(\theta_i + \phi_{i+1})}{\overline{\tau}_{i+1}} - 6\theta_i \right).
% \]
%^^A
% Let us rearrange that to the following:
%^^A
% \begin{align*}
%   d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 &\theta_{i-1} \\
%^^A
% +
% d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (1 - 3 \tau_{i-1}) &\phi_i \\
%^^A
% -
%  d_{i-1} \tau_{i-1} \tau_i^2 (1 - 3 \overline{\tau}_{i+1}) &\theta_i \\
%^^A
% -
%  d_{i-1} \tau_{i-1} \tau_i^2 &\phi_{i+1} \\
%^^A
% =
% 0
% \end{align*}
%^^A
% For both open and closed paths this holds for \(i=1\) to \(i=n' - 1\).
% 
% We also have the condition that \(\theta_i + \phi_i = -\psi_i\) where \(\psi_i\) is the angle subtended at a node by the lines to the adjacent nodes.
% This holds for the internal nodes\footnote{Recall that by dint of repetition, all nodes are effectively internal for a closed path}.
% Therefore for \(i=1\) to \(n'-1\) the above simplifies to the following:
% %
% \begin{align*}
%   d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 &\theta_{i-1} \\
% +
% (d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1)
% +
%  d_{i-1} \tau_{i-1} \tau_i^2 (3 \overline{\tau}_{i+1} - 1)) &\theta_i \\
% +
%  d_{i-1} \tau_{i-1} \tau_i^2 & \theta_{i+1} \\
% =
% - d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1) &\psi_i \\
% - d_{i-1} \tau_{i-1} \tau_i^2& \psi_{i+1}
% \end{align*}
% 
% For an open path we have two more equations.
% One involves \(\theta_0\).
% The other is the above for \(i = n'-1 = n-1\) with additional information regarding \(\psi_n\).
% It may be that one or either of \(\theta_0\) or \(\psi_n\) is specified in advance.
% In that case, the first equation is simply setting \(\theta_0\) to that value and the last equation involves substituting the value for \(\psi_n\) into the above.
% If not, they are given by formulae involving ``curl'' parameters \(\chi_0\) and \(\chi_n\) and result in the equations:
% %
% \begin{align*}
% \theta_0 &= \frac{\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)}{\tau_0^3(3 \overline{\tau}_1 - 1) + \chi_0 \overline{\tau}_1^3} \phi_1 \\
% \phi_n &= \frac{\overline{\tau}_n^3 + \chi_n \tau_{n-1}^3(3 \overline{\tau}_n - 1)}{\overline{\tau}_n^3(3 \tau_{n-1} - 1) + \chi_n \tau_{n-1}^3} \theta_{n-1}
% \end{align*}
%^^A
% Using \(\phi_1 = - \psi_1 - \theta_1\), the first rearranges to:
%^^A
% \[
% (\tau_0^3(3 \overline{\tau}_1 - 1) + \chi_0 \overline{\tau}_1^3) \theta_0 + (\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)) \theta_1 = - (\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)) \psi_1.
% \]
%^^A
% The second should be substituted in to the general equation with \(i = n-1\).
% This yields:
%^^A  
% \begin{align*}
%   d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 &\theta_{n-2} \\
% +
% (d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1)
% +
%  d_{n-2} \tau_{n-2} \tau_{n-1}^2 (3 \overline{\tau}_{n} - 1) \\
% - d_{n-2} \tau_{n-2} \tau_{n-1}^2  \frac{\overline{\tau}_n^3 + \chi_n \tau_{n-1}^3(3 \overline{\tau}_n - 1)}{\overline{\tau}_n^3(3 \tau_{n-1} - 1) + \chi_n \tau_{n-1}^3}) & \theta_{n-1} \\
% =
% - d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) &\psi_{n-1}
% \end{align*}
%
% For a closed path, we have one more equation.
% This is the identification of \(\theta_0\) with \(\theta_{n'-1}\).
%
% The result is a linear system with \(n' \times n'\) coefficient matrix.
% It is more natural to index the entries from \(0\).
% For an open path it is a tridiagonal coefficient matrix.
% For a closed path the equation \(\theta_0 = \theta_{n'-1}\) makes it no longer tridiagonal but it differs only by the \((0,n'-1)\)--{}entry.
% Let us write \(A_i\) for the subdiagonal, \(B_i\) for the main diagonal, and \(C_i\) for the superdiagonal.
% Let us write \(D_i\) for the target vector.
% Then for an open path we have the following formulae:
%^^A
% \begin{align*}
% A_i &= d_i \overline{\tau}_{i+1} \overline{\tau}^2_i \\
% B_0 &= \begin{cases}
% 1 & \text{if}\; \theta_0\; \text{given} \\
% \tau_0^3(3 \overline{\tau}_1 - 1) + \chi_0 \overline{\tau}^3_1 & \text{otherwise}
% \end{cases} \\
% B_i &= d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} -1) + d_{i-1} \tau_{i-1} \tau_i^2(3 \overline{\tau}_{i+1} - 1) \\
% B_{n-1} &= \begin{cases} d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) + d_{n-2} \tau_{n-2} \tau_{n-1}^2(3 \overline{\tau}_{n} - 1) & \text{if}\; \phi_n\; \text{given} \\
%  d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) + d_{n-2} \tau_{n-2} \tau_{n-1}^2(3 \overline{\tau}_{n} - 1)
% \\
% - d_{n-2} \tau_{n-2} \tau_{n-1}^2  \frac{\overline{\tau}_n^3 + \chi_n \tau_{n-1}^3(3 \overline{\tau}_n - 1)}{\overline{\tau}_n^3(3 \tau_{n-1} - 1) + \chi_n \tau_{n-1}^3}) & \text{otherwise}
% \end{cases} \\
% C_0 &= \begin{cases}
% 0 & \text{if}\; \theta_0\; \text{given} \\
% \tau_0^3 + \chi_0 \overline{\tau}_1^3(3\tau_0 - 1) & \text{otherwise}
% \end{cases} \\
% C_i &= d_{i-1} \tau_{i-1} \tau_i^2 \\
% D_0 &= \begin{cases}
% \overline{\theta}_0 & \text{if}\; \theta_0\; \text{given} \\
%  - (\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)) \psi_1 & \text{otherwise}
% \end{cases} \\
% D_i &= - d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1) \psi_i
% - d_{i-1} \tau_{i-1} \tau_i^2 \psi_{i+1} \\
% D_{n-1} &= \begin{cases}
% - d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) \psi_{n-1} - d_{n-2} \tau_{n-2} \tau_{n-1}^2 \overline{\phi}_n & \text{if}\; \phi_n\; \text{given} \\
% - d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) \psi_{n-1} & \text{otherwise}
% \end{cases}
% \end{align*}
%
% For a closed path, the formulae are the following:
%^^A
% \begin{align*}
% A_i &= d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 \\
%^^A
% B_0 &= 1 \\
%^^A
% B_i &= d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} -1) + d_{i-1} \tau_{i-1} \tau_i^2(3 \overline{\tau}_{i+1} - 1) \\
%^^A
% C_0 &= 0 \\
%^^A
% C_i &= d_{i-1} \tau_{i-1} \tau_i^2 \\
%^^A
% D_0 &= 0 \\
%^^A
% D_i &= - d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1) \psi_i
% - d_{i-1} \tau_{i-1} \tau_i^2 \psi_{i+1} \\
% \end{align*}
%^^A
% This is not quite the real matrix as it does not include the \((0,n'-1)\)--{}term which is \(-1\).
% However, it can be written in the form \(M + u v^\top\) with \(M\) tridiagonal and \(u = e_0\), \(v = - e_{n'-1}\).
% Doing this means that we can use the Sherman--{}Morrison formula:
%^^A
% \[
% (M + u v^\top)^{-1} = M^{-1} - \frac{M^{-1} u v^\top M^{-1}}{1 + v^\top M^{-1} u}.
% \]
%^^A
% So to compute \((M + u v^\top)^{-1} D\) we need to compute \(M^{-1} D\) and \(M^{-1} u\).
%
% The next step in the implementation is to compute these coefficients and store them in appropriate property lists.
% Having done that, we need to solve the resulting tridiagonal system.
% This is done by looping through the arrays doing the following substitutions (starting at \(i = 1\)):
% %
% \begin{align*}
% B_i' &= B_{i-1}' B_i - A_i C_{i-1}' \\
% C_i' &= B_{i-1}' C_i \\
% D_i' &= B_{i-1}' D_i - A_i D_{i-1}'
% \end{align*}
%^^A
% followed by back-substitution:
%^^A
% \begin{align*}
% \theta_{n-1} &= D_{n-1}'/B_{n-1}' \\
% \theta_i &= (D_i' - C_i' \theta_{i+1})/B_i'
% \end{align*}
%^^A
% For a closed path, we run this both with the vector \(D\) and the vector \(u = e_0\).
% Then we take the inner product of each with \(-e_{n'-1}^\top\) which selects (and negates) the \(n'-1\)th term, and substitute into the Sherman--{}Morrison formula to get the \(\theta_i\).
% 
% This leaves us with the values for \(\theta_i\).
% We now substitute these into Hobby's formulae for the lengths:
% %
% \begin{align*}
% \rho_i &= \frac{2 + \alpha_i}{1 + (1 - c) \cos \theta_i + c \cos \phi_{i+1}} \\
% \sigma_{i+1} &= \frac{2 - \alpha_i}{1 + (1 - c) \cos \phi_{i+1} + c \cos \theta_i} \\
% \alpha_i &= a (\sin \theta_i - b \sin \phi_{i+1})(\sin \phi_{i+1} - b \sin \theta_i)(\cos \theta_i - \cos \phi_{i+1})
% \end{align*}
% %
% where \(a = \sqrt{2}\), \(b = 1/16\), and \(c = (3 - \sqrt{5})/2\).
% 
% Now \(\theta_i\) is the angle relative to the line from \(z_i\) to \(z_{i+1}\), so to get the true angle we need to add back that angle.
% Fortunately, we stored those angles at the start.
% So the control points are:
% %
% \begin{gather*}
%   (\rho_i \cos (\theta_i + \omega_i), \rho_i \sin (\theta_i + \omega_i)) + z_i \\
% (-\sigma_i \cos(\theta_i + \omega_i), -\sigma_i \sin(\theta_i + \omega_i)) + z_{i+1}
% \end{gather*}
% 
% 
% \begin{tikzpicture}
% \fill[green] (0,0) circle[radius=2pt]
%  (6,4) circle[radius=2pt]
%  (4,9) circle[radius=2pt]
%  (1,7) circle[radius=2pt]
%  (3,5) circle[radius=2pt];
% \draw[postaction=show curve controls,thick] (0,0) to[curve through={(6,4) .. (4,9) .. (1,7)}] (3,5);
% 
% \draw[scale=.1,postaction=show curve controls,thick,blue] (0,0)
% .. controls (26.76463,-1.84543) and (51.4094,14.58441) .. (60,40)
% .. controls (67.09875,61.00188) and (59.76253,84.57518) .. (40,90)
% .. controls (25.35715,94.01947) and (10.48064,84.5022) .. (10,70)
% .. controls (9.62895,58.80421) and (18.80421,49.62895) .. (30,50);
% 
% \end{tikzpicture}
% 
%
% \StopEventually{\PrintChanges}
% \section{Implementation}
%
% \subsection{Main Code}
%
% \iffalse
%<*hobby>
% \fi
%
% We use \LaTeX3 syntax so need to load the requisite packages
%    \begin{macrocode}
\RequirePackage{expl3}
\ExplSyntaxOn
%    \end{macrocode}
% 
% We declare all our variables.
% These are the globals.
%
% The function for computing the lengths of the control points depends on three parameters.
%    \begin{macrocode}
\fp_new:N \g_hobby_parama_fp
\fp_new:N \g_hobby_paramb_fp
\fp_new:N \g_hobby_paramc_fp

\fp_set:Nn \g_hobby_parama_fp {2}
\fp_pow:Nn \g_hobby_parama_fp {.5}

\fp_set:Nn \g_hobby_paramb_fp {1}
\fp_div:Nn \g_hobby_paramb_fp {16}

\fp_set:Nn \g_hobby_paramc_fp {5}
\fp_pow:Nn \g_hobby_paramc_fp {.5}
\fp_neg:N \g_hobby_paramc_fp
\fp_add:Nn \g_hobby_paramc_fp {3}
\fp_div:Nn \g_hobby_paramc_fp {2}
%    \end{macrocode}
%
% Now we define our objects for use in processing the path.
%
% \begin{macro}{\l_hobby_closed_bool}
% \Verb+\l_hobby_closed_bool+
%    \begin{macrocode}
\bool_new:N \l_hobby_closed_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_points_seq}
% \Verb+\l_hobby_points_seq+
%    \begin{macrocode}
\seq_new:N \l_hobby_points_seq
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_path_tl}
% \Verb+\l_hobby_path_tl+
%    \begin{macrocode}
\tl_new:N \l_hobby_path_tl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_points_prop}
% \Verb+\l_hobby_points_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_points_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_pointsx_prop}
% \Verb+\l_hobby_pointsx_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_pointsx_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_pointsy_prop}
% \Verb+\l_hobby_pointsy_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_pointsy_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_angles_prop}
% \Verb+\l_hobby_angles_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_angles_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_distances_prop}
% \Verb+\l_hobby_distances_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_distances_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tensionout_prop}
% \Verb+\l_hobby_tensionout_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_tensionout_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tensionin_prop}
% \Verb+\l_hobby_tensionin_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_tensionin_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tria_prop}
% \Verb+\l_hobby_tria_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_tria_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_trib_prop}
% \Verb+\l_hobby_trib_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_trib_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tric_prop}
% \Verb+\l_hobby_tric_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_tric_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_trid_prop}
% \Verb+\l_hobby_trid_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_trid_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_psi_prop}
% \Verb+\l_hobby_psi_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_psi_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_psid_prop}
% \Verb+\l_hobby_psid_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_psid_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_theta_prop}
% \Verb+\l_hobby_theta_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_theta_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_phi_prop}
% \Verb+\l_hobby_phi_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_phi_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_sigma_prop}
% \Verb+\l_hobby_sigma_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_sigma_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_rho_prop}
% \Verb+\l_hobby_rho_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_rho_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_alpha_prop}
% \Verb+\l_hobby_alpha_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_alpha_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_controla_prop}
% \Verb+\l_hobby_controla_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_controla_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_controlb_prop}
% \Verb+\l_hobby_controlb_prop+
%    \begin{macrocode}
\prop_new:N \l_hobby_controlb_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_x_dim}
% \Verb+\l_hobby_x_dim+
%    \begin{macrocode}
\dim_new:N \l_hobby_x_dim
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_y_dim}
% \Verb+\l_hobby_y_dim+
%    \begin{macrocode}
\dim_new:N \l_hobby_y_dim
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempa_fp}
% \Verb+\l_hobby_tempa_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_tempa_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempb_fp}
% \Verb+\l_hobby_tempb_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_tempb_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempc_fp}
% \Verb+\l_hobby_tempc_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_tempc_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempd_fp}
% \Verb+\l_hobby_tempd_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_tempd_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_temps_fp}
% \Verb+\l_hobby_temps_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_temps_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_incurl_fp}
% \Verb+\l_hobby_incurl_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_incurl_fp
\fp_set:Nn \l_hobby_incurl_fp {1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_outcurl_fp}
% \Verb+\l_hobby_outcurl_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_outcurl_fp
\fp_set:Nn \l_hobby_outcurl_fp {1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_inang_fp}
% \Verb+\l_hobby_inang_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_inang_fp
\fp_set_eq:NN \l_hobby_inang_fp \c_undefined_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_outang_fp}
% \Verb+\l_hobby_outang_fp+
%    \begin{macrocode}
\fp_new:N \l_hobby_outang_fp
\fp_set_eq:NN \l_hobby_outang_fp \c_undefined_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_npoints_int}
% \Verb+\l_hobby_npoints_int+
%    \begin{macrocode}
\int_new:N \l_hobby_npoints_int
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_temp_int}
% \Verb+\l_hobby_temp_int+
%    \begin{macrocode}
\int_new:N \l_hobby_temp_int
%    \end{macrocode}
% \end{macro}
%
% A ``point'' is a key-value list setting the x-value, the y-value, and the tensions at that point.
%    \begin{macrocode}
\keys_define:nn {hobby / read in all} {
  x .fp_set:N = \l_hobby_tempa_fp,
  y .fp_set:N = \l_hobby_tempb_fp,
  tension~out .fp_set:N = \l_hobby_tempc_fp,
  tension~in .fp_set:N = \l_hobby_tempd_fp,
  tension~out .default:n = 1,
  tension~in .default:n = 1,
}
\keys_define:nn { hobby / read in params} {
  in~angle .fp_set:N = \l_hobby_inang_fp,
  out~angle .fp_set:N = \l_hobby_outang_fp,
  in~curl .fp_set:N = \l_hobby_incurl_fp,
  out~curl .fp_set:N = \l_hobby_outcurl_fp,
  closed .bool_set:N = \l_hobby_closed_bool,
  closed .default:n = true,
}
%    \end{macrocode}
% \begin{macro}{\hobby_distangle:n}
% Computes the distance and angle between successive points.
% The argument given is the index of the current point.
% Assumptions: the points are in \Verb+\l_hobby_pointsx_prop+ and \Verb+\l_hobby_pointsy_prop+ and the index of the last point is \Verb+\l_hobby_npoints_int+.
%    \begin{macrocode}
\cs_set:Nn \hobby_distangle:n {
    \int_compare:nTF { #1 < \l_hobby_npoints_int }
    {
      \int_set:Nn \l_hobby_temp_int {#1}
      \int_incr:N \l_hobby_temp_int
    }
    {
      \int_seq:Nn \l_hobby_temp_int {0}
    }
    \exp_args:NNo \prop_get:NnN \l_hobby_pointsx_prop {\int_use:N \l_hobby_temp_int} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \exp_args:NNo \prop_get:NnN \l_hobby_pointsy_prop {\int_use:N \l_hobby_temp_int} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

    \prop_get:NnN \l_hobby_pointsx_prop {#1} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {#1} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

    \fp_atantwo:NNN \l_hobby_tempc_fp \l_hobby_tempb_fp \l_hobby_tempa_fp
    \fp_veclen:NNN \l_hobby_tempd_fp \l_hobby_tempa_fp \l_hobby_tempb_fp

    \prop_put:Nnx \l_hobby_angles_prop {#1} {\fp_to_tl:N \l_hobby_tempc_fp}
    \prop_put:Nnx \l_hobby_distances_prop {#1} {\fp_to_tl:N \l_hobby_tempd_fp}
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fp_atantwo:NNN}
% Computes the angle of the point specified by the latter two arguments, storing the answer in the first.
%    \begin{macrocode}
\cs_new:Nn \fp_atantwo:NNN {
  \pgfmathparse{rad(atan2(\fp_use:N #3,\fp_use:N #2))}
  \exp_args:NNo \fp_set:Nn #1 {\pgfmathresult}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_veclen:NNN}
% Computes the length of the vector specified by the latter two arguments, storing the answer in the first.
% Needs temporary variables.
%    \begin{macrocode}
\fp_new:N \l_hobby_veclena_fp
\fp_new:N \l_hobby_veclenb_fp
\cs_new:Nn \fp_veclen:NNN {
  \fp_set_eq:NN \l_hobby_veclena_fp #2
  \fp_set_eq:NN \l_hobby_veclenb_fp #3
  \fp_mul:Nn \l_hobby_veclena_fp {\l_hobby_veclena_fp}
  \fp_mul:Nn \l_hobby_veclenb_fp {\l_hobby_veclenb_fp}
  \fp_add:Nn \l_hobby_veclena_fp {\l_hobby_veclenb_fp}
  \fp_pow:Nn \l_hobby_veclena_fp {.5}
  \fp_set_eq:NN #1 \l_hobby_veclena_fp
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobby_genpath:}
% This is the curve generation function.
% We assume at the start that we have a property list containing all the points that the curve must go through, and the various curve parameters have been initialised.
% So these must be set up by a wrapper function which then calls this one.
% The list of required information is:
% \begin{enumerate}
% \item \Verb+\l_hobby_pointsx_prop+
% \item \Verb+\l_hobby_pointsy_prop+
% \item \Verb+\l_hobby_npoints_int+
% \item \Verb+\l_hobby_tensionout_prop+
% \item \Verb+\l_hobby_tensionin_prop+
% \item \Verb+\l_hobby_incurl_fp+
% \item \Verb+\l_hobby_outcurl_fp+
% \item \Verb+\l_hobby_inang_fp+
% \item \Verb+\l_hobby_outang_fp+
% \item \Verb+\l_hobby_closed_bool+
% \end{enumerate}
%
%    \begin{macrocode}
\cs_new:Nn \hobby_genpath:
{
%    \end{macrocode}
% For much of the time, we can pretend that a closed path is the same as an open path.
% To do this, we need to make the end node an internal node by repeating the \(z_1\) node as the \(z_{n+1}\)th node.
% We also check that the last and first nodes are the same, otherwise we repeat the \(z_0\) node as well.
%    \begin{macrocode}
\bool_if:NTF \l_hobby_closed_bool {
  \prop_get:NnN \l_hobby_pointsx_prop {0} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \exp_args:NNo \prop_get:NnN \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_sub:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_compare:nNnTF {\l_hobby_tempa_fp} = {\c_zero_fp}
  {
    \prop_get:NnN \l_hobby_pointsy_prop {0} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \exp_args:NNo \prop_get:NnN \l_hobby_pointsy_prop {\int_use:N       \l_hobby_npoints_int} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \fp_compare:nNnTF {\l_hobby_tempa_fp} = {\c_zero_fp}
  {}
  {
    \int_incr:N \l_hobby_npoints_int
    \prop_get:NnN \l_hobby_points_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsx_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionin_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
  }
  }
  {
    \int_incr:N \l_hobby_npoints_int
    \prop_get:NnN \l_hobby_points_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsx_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionin_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
  }
    \int_incr:N \l_hobby_npoints_int
    \prop_get:NnN \l_hobby_points_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsx_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionout_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
}{}
%    \end{macrocode}
% 
% Our first step is to go through the list of points and compute the distances and angles between successive points.
% Thus \(d_i\) is the distance from \(z_i\) to \(z_{i+1}\) and the angle is the angle of the line from \(z_i\) to \(z_{i+1}\).

%    \begin{macrocode}
\prg_stepwise_function:nnnN {0} {1} {\l_hobby_npoints_int - 1} \hobby_distangle:n
%    \end{macrocode}
%
% For the majority of the code, we're only really interested in the differences of the angles.
% So for each internal point we compute the differences in the angles.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \exp_args:NNx \prop_get:NnN \l_hobby_angles_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_angles_prop {##1} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempa_fp {\tl_use:N \l_tmpa_tl}
    \fp_compare:nNnTF {\l_hobby_tempa_fp} > { \c_pi_fp }
    {
      \fp_sub:Nn \l_hobby_tempa_fp {\c_pi_fp}
      \fp_sub:Nn \l_hobby_tempa_fp {\c_pi_fp}
    }
    {}
    \fp_set_eq:NN \l_hobby_tempb_fp \l_hobby_tempa_fp
    \fp_neg:N \l_hobby_tempb_fp
    \fp_compare:nNnTF {\l_hobby_tempb_fp} > {\c_pi_fp }
    {
      \fp_add:Nn \l_hobby_tempa_fp {\c_pi_fp}
      \fp_add:Nn \l_hobby_tempa_fp {\c_pi_fp}
    }
    {}
    \prop_put:Nnx \l_hobby_psi_prop {##1}{\fp_to_tl:N \l_hobby_tempa_fp}
  }
%    \end{macrocode}
%
% Next, we generate the matrix.
% We start with the subdiagonal.
% This is indexed from \(1\) to \(n-1\).
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_put:Nnx \l_hobby_tria_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
  }
%    \end{macrocode}
%
% Next, we attack main diagonal.
% We might need to adjust the first and last terms, but we'll do that in a minute.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {3}
  \fp_sub:Nn \l_hobby_tempa_fp {1}

  \prop_get:NnN \l_hobby_tensionout_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \prop_put:Nnx \l_hobby_trib_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Next, the superdiagonal.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 2} {
  \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_put:Nnx \l_hobby_tric_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Lastly (before the adjustments), the target vector.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
  \exp_args:NNx \prop_get:NnN \l_hobby_psi_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_tensionout_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_neg:N \l_hobby_tempa_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_psi_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \prop_put:Nnx \l_hobby_trid_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Next, there are some adjustments at the ends.
% These differ depending on whether the path is open or closed.
% First, we test to see if \(\theta_0\) has been specified.
%    \begin{macrocode}
\bool_if:NTF \l_hobby_closed_bool {
%    \end{macrocode}
% Closed path
%    \begin{macrocode}
\prop_put:NnN \l_hobby_trib_prop {0} {1}
\prop_put:NnN \l_hobby_tric_prop {0} {0}
\prop_put:NnN \l_hobby_trid_prop {0} {0}
}
{
%    \end{macrocode}
% Open path
%    \begin{macrocode}
\fp_if_undefined:NTF \l_hobby_inang_fp
{
  \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_incurl_fp}

  \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}
  
  \prop_put:Nnx \l_hobby_trib_prop {0}  {\fp_to_tl:N \l_hobby_tempa_fp}

  \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempb_fp {\l_hobby_incurl_fp}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}
  
  \prop_put:Nnx \l_hobby_tric_prop {0} {\fp_to_tl:N \l_hobby_tempa_fp}

  \fp_neg:N \l_hobby_tempa_fp

  \prop_get:NnN \l_hobby_psi_prop {1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  
  \prop_put:Nnx \l_hobby_trid_prop {0} {\fp_to_tl:N \l_hobby_tempa_fp}
  
}
{
  \prop_put:Nnn \l_hobby_trib_prop {0} {1}
  \prop_put:Nnn \l_hobby_tric_prop {0} {0}
  \prop_put:Nnx \l_hobby_trid_prop {0} {\fp_to_tl:N \l_hobby_inang_fp}
}
%    \end{macrocode}
%
% Next, if \(\psi_n\) has been given.
%    \begin{macrocode}
\fp_if_undefined:NTF \l_hobby_outang_fp
{
  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n     {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempb_fp {\l_hobby_outcurl_fp}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int } \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempb_fp {\l_hobby_tempc_fp}

  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempc_fp {\l_hobby_outcurl_fp}

  \fp_add:Nn \l_hobby_tempb_fp {\l_hobby_tempc_fp}

  \fp_div:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \fp_neg:N \l_hobby_tempa_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl

  \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_put:Nnx \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}


  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_psi_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_neg:N \l_hobby_tempb_fp

  \exp_args:NNx \prop_put:Nnx \l_hobby_trid_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempb_fp}
}
{
  \fp_set_eq:NN \l_hobby_tempa_fp \l_hobby_outang_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_in - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_neg:N \l_hobby_tempa_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_psi_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \exp_args:NNx \prop_put:Nnx \l_hobby_trid_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
% End of adjustments for open paths.
%    \begin{macrocode}
}
%    \end{macrocode}
%
% Now we have the tridiagonal matrix in place, we implement the solution.
%
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trib_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tric_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tria_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempb_fp {\l_hobby_tempa_fp}

  \prop_put:Nnx \l_hobby_trib_prop {##1} {\fp_to_tl:N \l_hobby_tempb_fp}

  \int_compare:nTF {##1 < \l_hobby_npoints_int - 1} {

  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tric_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_put:Nnx \l_hobby_tric_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
  }
  {}

  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trid_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_trid_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tria_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempb_fp {\l_hobby_tempa_fp}

  \prop_put:Nnx \l_hobby_trid_prop {##1} {\fp_to_tl:N \l_hobby_tempb_fp}
}

\exp_args:NNx \prop_get:NnN \l_hobby_trid_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_div:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_put:Nnx \l_hobby_theta_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}

\prg_stepwise_inline:nnnn {\l_hobby_npoints_int - 2} {-1} {0} {
  \exp_args:NNx \prop_get:NnN \l_hobby_theta_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tric_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trid_prop {##1} \l_tmpa_tl
  \fp_neg:N \l_hobby_tempa_fp
  \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trib_prop {##1} \l_tmpa_tl
  \fp_div:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_put:Nnx \l_hobby_theta_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Now that we have computed the \(\theta_i\)s, we can quickly compute the \(\phi_i\)s.
%
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \prop_get:NnN \l_hobby_theta_prop {##1} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_psi_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \fp_neg:N \l_hobby_tempa_fp
    \prop_put:Nnx \l_hobby_phi_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
  }
%    \end{macrocode}
%
% This works for all except \(\psi_n\).
%
%    \begin{macrocode}
  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {3}
  \fp_sub:Nn \l_hobby_tempa_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n     {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_outcurl_fp}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int } \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempc_fp {\l_hobby_outcurl_fp}

  \fp_add:Nn \l_hobby_tempb_fp {\l_hobby_tempc_fp}

  \fp_div:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

\exp_args:NNx \prop_get:NnN \l_hobby_theta_prop {\int_eval:n {\l_hobby_npoints_int -1}} \l_tmpa_tl
\fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_put:Nnx \l_hobby_phi_prop {\int_use:N \l_hobby_npoints_int} {\fp_to_tl:N \l_hobby_tempa_fp}
%    \end{macrocode}
%
% Next task is to compute the \(\rho_i\) and \(\sigma_i\).
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {0} {1} {\l_hobby_npoints_int - 1} {

  \prop_get:NnN \l_hobby_theta_prop {##1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

    \exp_args:NNx \prop_get:NnN \l_hobby_phi_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  
    \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

    \fp_set:Nn \l_hobby_temps_fp {0}

    \fp_cos:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_cos:Nn \l_hobby_tempd_fp {\l_hobby_tempb_fp}

    \fp_set_eq:NN \l_hobby_temps_fp \l_hobby_tempc_fp
    \fp_sub:Nn \l_hobby_temps_fp {\l_hobby_tempd_fp}

    \fp_sin:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempb_fp}

    \fp_mul:Nn \l_hobby_tempc_fp {\g_hobby_paramb_fp}
    \fp_sub:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}
    \fp_mul:Nn \l_hobby_temps_fp {\l_hobby_tempd_fp}

    \fp_sin:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempb_fp}

    \fp_mul:Nn \l_hobby_tempd_fp {\g_hobby_paramb_fp}
    \fp_sub:Nn \l_hobby_tempc_fp {\l_hobby_tempd_fp}
    \fp_mul:Nn \l_hobby_temps_fp {\l_hobby_tempc_fp}

    \fp_mul:Nn \l_hobby_temps_fp {\g_hobby_parama_fp}

    \fp_cos:Nn \l_hobby_tempa_fp {\l_hobby_tempa_fp}
    \fp_cos:Nn \l_hobby_tempb_fp {\l_hobby_tempb_fp}

    \fp_set_eq:NN \l_hobby_tempc_fp \l_hobby_tempa_fp
    \fp_sub:Nn \l_hobby_tempc_fp {\l_hobby_tempb_fp}
    \fp_mul:Nn \l_hobby_tempc_fp {\g_hobby_paramc_fp}

    \fp_add:Nn \l_hobby_tempc_fp {\l_hobby_tempb_fp}
    \fp_add:Nn \l_hobby_tempc_fp {1}

    \fp_set_eq:NN \l_hobby_tempd_fp \l_hobby_temps_fp

    \fp_neg:N \l_hobby_tempd_fp
    \fp_add:Nn \l_hobby_tempd_fp {2}

    \fp_div:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}

  \exp_args:NNx \prop_put:Nnx \l_hobby_sigma_prop {\int_eval:n{##1 + 1}} {\fp_to_tl:N \l_hobby_tempd_fp}

    \fp_set_eq:NN \l_hobby_tempc_fp \l_hobby_tempa_fp
    \fp_sub:Nn \l_hobby_tempc_fp {\l_hobby_tempb_fp}
    \fp_mul:Nn \l_hobby_tempc_fp {\g_hobby_paramc_fp}
    \fp_neg:N \l_hobby_tempc_fp

    \fp_add:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_add:Nn \l_hobby_tempc_fp {1}

    \fp_set_eq:NN \l_hobby_tempd_fp \l_hobby_temps_fp

    \fp_add:Nn \l_hobby_tempd_fp {2}

    \fp_div:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}

   \prop_put:Nnx \l_hobby_rho_prop {##1} {\fp_to_tl:N \l_hobby_tempd_fp}

  }

  \prop_map_inline:Nn \l_hobby_theta_prop {
    \prop_get:NnN \l_hobby_angles_prop {##1} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_sub:Nn \l_hobby_tempc_fp {##2}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}
    \fp_cos:Nn \l_hobby_tempc_fp {\l_hobby_tempc_fp}
    \prop_get:NnN \l_hobby_rho_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_div:Nn \l_hobby_tempd_fp {3}
    \fp_div:Nn \l_hobby_tempc_fp {3}
  \prop_get:NnN \l_hobby_pointsx_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_pointsy_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
  \exp_args:NNx \prop_put:Nnx \l_hobby_controla_prop {\int_eval:n {##1 + 1}} {x = \fp_use:N \l_hobby_tempc_fp, y = \fp_use:N \l_hobby_tempd_fp }
  }

  \prop_map_inline:Nn \l_hobby_phi_prop {
    \exp_args:NNx \prop_get:NnN \l_hobby_angles_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_add:Nn \l_hobby_tempc_fp {##2}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}
    \fp_cos:Nn \l_hobby_tempc_fp {\l_hobby_tempc_fp}
    \fp_neg:N \l_hobby_tempc_fp
    \fp_neg:N \l_hobby_tempd_fp
    \prop_get:NnN \l_hobby_sigma_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \fp_div:Nn \l_hobby_tempc_fp {3}
    \fp_div:Nn \l_hobby_tempd_fp {3}
    \prop_get:NnN \l_hobby_pointsx_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \prop_put:Nnx \l_hobby_controlb_prop {##1} {x = \fp_use:N \l_hobby_tempc_fp, y = \fp_use:N \l_hobby_tempd_fp }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbyinit}
% Initialise the settings for Hobby's algorithm
%    \begin{macrocode}
\NewDocumentCommand \hobbyinit {m m} {
\hobby_set_cmds:nn#1#2
\prop_clear:N \l_hobby_points_prop
\prop_clear:N \l_hobby_pointsx_prop
\prop_clear:N \l_hobby_pointsy_prop
\prop_clear:N \l_hobby_angles_prop
\prop_clear:N \l_hobby_distances_prop
\prop_clear:N \l_hobby_tensionout_prop
\prop_clear:N \l_hobby_tensionin_prop
\prop_clear:N \l_hobby_tria_prop
\prop_clear:N \l_hobby_trib_prop
\prop_clear:N \l_hobby_tric_prop
\prop_clear:N \l_hobby_trid_prop
\prop_clear:N \l_hobby_psi_prop
\prop_clear:N \l_hobby_psid_prop
\prop_clear:N \l_hobby_theta_prop
\prop_clear:N \l_hobby_phi_prop
\prop_clear:N \l_hobby_sigma_prop
\prop_clear:N \l_hobby_rho_prop
\prop_clear:N \l_hobby_alpha_prop
\prop_clear:N \l_hobby_controla_prop
\prop_clear:N \l_hobby_controlb_prop

  \int_set:Nn \l_hobby_npoints_int {-1}
  \fp_set_eq:NN \l_hobby_inang_fp \c_undefined_fp
  \fp_set_eq:NN \l_hobby_outang_fp \c_undefined_fp
  \fp_set_eq:NN \l_hobby_incurl_fp \c_one_fp
  \fp_set_eq:NN \l_hobby_outcurl_fp \c_one_fp
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbyaddpoint}
%    \begin{macrocode}
\NewDocumentCommand \hobbyaddpoint { m } {
    \keys_set:nn { hobby/read in all }
    {
      tension~out,
      tension~in,
      #1
    }
    \int_incr:N \l_hobby_npoints_int
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempc_fp}
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempd_fp}
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int } {x = \fp_use:N \l_hobby_tempa_fp, y = \fp_use:N \l_hobby_tempb_fp }
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempa_fp}
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempb_fp}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbysetparams}
%    \begin{macrocode}
\NewDocumentCommand \hobbysetparams { m } {
  \keys_set:nn { hobby / read in params }
  {
    #1
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbygenpath}
%    \begin{macrocode}
\cs_new:Nn \hobby_set_cmds:nn {
  \cs_set_eq:NN \hobby_moveto:n #1
  \cs_set_eq:NN \hobby_curveto:nnn #2
}
\tl_new:N \l_tmpc_tl
\NewDocumentCommand \hobbygenpath { } {
  \hobby_genpath:
  \prop_get:NnN \l_hobby_points_prop {0} \l_tmpa_tl
  \exp_args:No \hobby_moveto:n {\l_tmpa_tl}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int} {
    \prop_get:NnN \l_hobby_controla_prop {##1} \l_tmpa_tl
    \prop_get:NnN \l_hobby_controlb_prop {##1} \l_tmpb_tl
    \prop_get:NnN \l_hobby_points_prop {##1} \l_tmpc_tl
    \exp_args:Nooo \hobby_curveto:nnn {\l_tmpa_tl} {\l_tmpb_tl} {\l_tmpc_tl}
}
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
% \iffalse
%</hobby>
% \fi
%
% \subsection{PGF Library}
%
% \iffalse
%<*pgflibrary>
% \fi
% 
%    \begin{macrocode}
\input{hobby.code.tex}

\pgfkeys{
  /pgf/hobby/.is family,
  /pgf/hobby/.cd,
  x/.code={\pgf@x=#1cm},
  y/.code={\pgf@y=#1cm},
}

\def\hobby@curveto#1#2#3{
  \pgfpathcurveto{\hobby@topgf{#1}}{\hobby@topgf{#2}}{\hobby@topgf{#3}}%
}

\def\hobby@topgf#1{%
    \pgfqkeys{/pgf/hobby}{#1}
}

%    \end{macrocode}
% \iffalse
%</pgflibrary>
% \fi
%
% \subsection{TikZ Library}
%
% \iffalse
%<*tikzlibrary>
% \fi
% 
%    \begin{macrocode}
%
\usepgflibrary{hobby}

\let\hobby@opts=\pgfutil@empty

\tikzset{
  curve through/.style={
    to path={
      \pgfextra{
        \expandafter\curvethrough\expandafter[\hobby@opts]{(\tikztostart) .. #1 .. (\tikztotarget)}
      }
    }
  },
  tension in/.code = {},
  tension out/.code = {},
  closed/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts closed=#1}%
  },
  closed/.default = true,
  in angle/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts in       angle=#1,}%
  },
  out angle/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts out angle=#1,}%
  },
  in curl/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts in curl=#1,}%
  },
  out curl/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts out curl=#1,}%
  },
}
%    \end{macrocode}
% \begin{macro}{\curvethrough}
%    \begin{macrocode}
\newcommand\curvethrough[2][]{%
  \hobbyinit\pgfutil@gobble\hobby@curveto
  \hobbysetparams{#1}%
  \hobby@processpts{#2}%
}

\newcommand\hobby@processpts[1]{%
  \pgfutil@in@{..}{#1}%
  \ifpgfutil@in@%
    \hobby@getonepoint #1 \relax
    \let\hobby@next=\hobby@processpts
  \else
    \def\hobby@pt{#1}%
    \def\hobby@rest{}%
    \let\hobby@next=\hobbygenpath
  \fi
  \let\tikz@scan@point@options=\pgfutil@empty
  \expandafter\tikz@scan@one@point\expandafter\pgfutil@firstofone\hobby@pt\relax
  \pgfmathsetmacro\hobby@x{\the\pgf@x/1cm}%
  \pgfmathsetmacro\hobby@y{\the\pgf@y/1cm}%
  \expandafter\hobbyaddpoint\expandafter{\tikz@scan@point@options,x = \hobby@x, y = \hobby@y}%
  \expandafter\hobby@next\expandafter{\hobby@rest}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobby@onepoint}
%    \begin{macrocode}
\def\hobby@getonepoint#1..#2\relax{%
  \def\hobby@pt{#1}%
  \def\hobby@rest{#2}%
}
%    \end{macrocode}
% \end{macro}
% \iffalse
%</tikzlibrary>
% \fi
%
%\Finale