% \iffalse meta-comment
%<*internal>
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
Copyright (C) 2012 by Andrew Stacey
-------------------------------------------

This file may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at
 your option) any later version.
The latest version of this license is in:

   http://www.latex-project.org/lppl.txt

and version 1.3 or later is part of all distributions of LaTeX
version 2005/12/01 or later.
\endpreamble
\generate{\file{tikzlibraryhobby.code.tex} {\from{hobby.dtx}{tikzlibrary}}}
\generate{\file{pgflibraryhobby.code.tex} {\from{hobby.dtx}{pgflibrary}}}
\generate{\file{hobby.code.tex}
{\from{hobby.dtx}{hobby}}}
\generate{\file{pml3array.sty}
{\from{hobby.dtx}{array}}}
%</install>
%<install>\endbatchfile
%<*internal>
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass[full]{l3doc}
\usepackage[T1]{fontenc}
\usepackage{csquotes}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{amsmath}
\usetikzlibrary{hobby,decorations.pathreplacing}
\usepackage[margin=3cm]{geometry}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\addtolength{\hoffset}{.4in}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{1779}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
%
% \DoNotIndex{\newcommand,\newenvironment}
%
% \providecommand*{\url}{\texttt}
% \title{The \textsf{Hobby} package: code}
% \author{Andrew Stacey \\ \url{stacey@math.ntnu.no}}
% \maketitle
%
%
% \StopEventually{\PrintChanges}
% \section{Implementation}
%
% \subsection{Main Code}
%
% \iffalse
%<*hobby>
% \fi
%
% We use \LaTeX3 syntax so need to load the requisite packages
%    \begin{macrocode}
\RequirePackage{expl3}
\RequirePackage{xparse}
\RequirePackage{pml3array}
\ExplSyntaxOn
%    \end{macrocode}
%
%    \begin{macrocode}
\cs_generate_variant:Nn \fp_set:Nn {Nx}
%    \end{macrocode}
%
% \subsubsection{Initialisation}
%
% We declare all our variables.
%
% The function for computing the lengths of the control points depends on three parameters.
% These are set to \(a = \sqrt{2}\), \(b = 1/16\), and \(c = \frac{3 - \sqrt{5}}{2}\).
%    \begin{macrocode}
\fp_new:N \g_hobby_parama_fp
\fp_new:N \g_hobby_paramb_fp
\fp_new:N \g_hobby_paramc_fp

\fp_gset:Nn \g_hobby_parama_fp {2^.5}

\fp_gset:Nn \g_hobby_paramb_fp {1/16}

\fp_gset:Nn \g_hobby_paramc_fp {(3-5^.5)/2}
%    \end{macrocode}
%
% Now we define our objects for use in generating the path.
%
% \begin{function}{\l_hobby_closed_bool}
% \Verb+\l_hobby_closed_bool+ is \Verb+true+ if the path is closed.
%    \begin{macrocode}
\bool_new:N \l_hobby_closed_bool
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_disjoint_bool}
% \Verb+\l_hobby_disjoint_bool+ is \Verb+true+ if the path should start with a \Verb+moveto+ command.
%    \begin{macrocode}
\bool_new:N \l_hobby_disjoint_bool
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_points_array}
% \Verb+\l_hobby_points_array+ is an array holding the specified points on the path.
% In the \LaTeX3 code, a ``point'' is a token list of the form \Verb+x = <number>, y = <number>+.
% This gives us the greatest flexibility in passing points back and forth between the \LaTeX3 code and any calling code.
% The array is indexed by integers beginning with \(0\).
% In the documentation, we will use the notation \(z_k\) to refer to the \(k\)th point.
%    \begin{macrocode}
\array_new:N \l_hobby_points_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_points_x_array}
% \Verb+\l_hobby_points_x_array+ is an array holding the \(x\)--{}coordinates of the specified points.
%    \begin{macrocode}
\array_new:N \l_hobby_points_x_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_points_y_array}
% \Verb+\l_hobby_points_y_array+ is an array holding the \(y\)--{}coordinates of the specified points.
%    \begin{macrocode}
\array_new:N \l_hobby_points_y_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_angles_array}
% \Verb+\l_hobby_angles_array+ is an array holding the angles of the lines between the points.
% Specifically, the angle indexed by \(k\) is the angle in radians of the line from \(z_k\) to \(z_{k+1}\).
%    \begin{macrocode}
\array_new:N \l_hobby_angles_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_distances_array}
% \Verb+\l_hobby_distances_array+ is an array holding the distances between the points.
% Specifically, the distance indexed by \(k\), which we will write as \(d_k\), is the length of the line from \(z_k\) to \(z_{k+1}\).
%    \begin{macrocode}
\array_new:N \l_hobby_distances_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_tension_out_array}
% \Verb+\l_hobby_tension_out_array+ is an array holding the tension for the path as it leaves each point.
% This is a parameter that controls how much the curve ``flexes'' as it leaves the point.
% In the following, this will be written \(\tau_k\).
%    \begin{macrocode}
\array_new:N \l_hobby_tension_out_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_tension_in_array}
% \Verb+\l_hobby_tension_in_array+ is an array holding the tension for the path as it arrives at each point.
% This is a parameter that controls how much the curve ``flexes'' as it gets to the point.
% In the following, this will be written \(\overline{\tau}_k\).
%    \begin{macrocode}
\array_new:N \l_hobby_tension_in_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_matrix_a_array}
% \Verb+\l_hobby_matrix_a_array+ is an array holding the subdiagonal of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(A_i\).
% The first index is \(1\).
%    \begin{macrocode}
\array_new:N \l_hobby_matrix_a_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_matrix_b_array}
% \Verb+\l_hobby_matrix_b_array+ is an array holding the diagonal of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(B_i\).
% The first index is \(0\).
%    \begin{macrocode}
\array_new:N \l_hobby_matrix_b_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_matrix_c_array}
% \Verb+\l_hobby_matrix_c_array+ is an array holding the superdiagonal of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(C_i\).
% The first index is \(0\).
%    \begin{macrocode}
\array_new:N \l_hobby_matrix_c_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_matrix_d_array}
% \Verb+\l_hobby_matrix_d_array+ is an array holding the target vector of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(D_i\).
% The first index is \(1\).
%    \begin{macrocode}
\array_new:N \l_hobby_matrix_d_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_vector_u_array}
% \Verb+\l_hobby_vector_u_array+ is an array holding the perturbation of the linear system for closed paths.
% The coefficient matrix for a \emph{open} path is tridiagonal and that means that Gaussian elimination runs faster than expected (\(O(n)\) instead of \(O(n^3)\)).
% The matrix for a closed path is not tridiagonal but is not far off.
% It can be solved by perturbing it to a tridiagonal matrix and then modifying the result.
% This array represents a utility vector in that perturbation. 
% In the following, the vector will be denoted by \(u\).
% The first index is \(1\).
%    \begin{macrocode}
\array_new:N \l_hobby_vector_u_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_excess_angle_array}
% \Verb+\l_hobby_excess_angle_array+ is an array that allows the user to say that the algorithm should add a multiple of \(2 \pi\) to the angle differences.
% This is because these angles are wrapped to the interval \((-\pi,\pi]\) but the wrapping might go wrong near the end points due to computation accuracy.
% The first index is \(1\).
%    \begin{macrocode}
\array_new:N \l_hobby_excess_angle_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_psi_array}
% \Verb+\l_hobby_psi_array+ is an array holding the difference of the angles of the lines entering and exiting a point.
% That is, \(\psi_k\) is the angle between the lines joining \(z_k\) to \(z_{k-1}\) and \(z_{k+1}\).
% The first index is \(1\).
%    \begin{macrocode}
\array_new:N \l_hobby_psi_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_theta_array}
% \Verb+\l_hobby_theta_array+ is an array holding the angles of the outgoing control points for the generated path.
% These are measured relative to the line joining the point to the next point on the path.
% The first index is \(0\).
%    \begin{macrocode}
\array_new:N \l_hobby_theta_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_phi_array}
% \Verb+\l_hobby_phi_array+ is an array holding the angles of the incoming control points for the generated path.
% These are measured relative to the line joining the point to the previous point on the path.
% The first index is \(1\).
%    \begin{macrocode}
\array_new:N \l_hobby_phi_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_sigma_array}
% \Verb+\l_hobby_sigma_array+ is an array holding the lengths of the outgoing control points for the generated path.
% The units are such that the length of the line to the next specified point is one unit.
%    \begin{macrocode}
\array_new:N \l_hobby_sigma_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_rho_array}
% \Verb+\l_hobby_rho_array+ is an array holding the lengths of the incoming control points for the generated path.
% The units are such that the length of the line to the previous specified point is one unit.
%    \begin{macrocode}
\array_new:N \l_hobby_rho_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_controla_array}
% \Verb+\l_hobby_controla_array+ is an array holding the coordinates of the first control points on the curves.
% The format is the same as for \Verb+\l_hobby_points_array+.
%    \begin{macrocode}
\array_new:N \l_hobby_controla_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_controlb_array}
% \Verb+\l_hobby_controlb_array+ is an array holding the coordinates of the second control points on the curves.
% The format is the same as for \Verb+\l_hobby_points_array+.
%    \begin{macrocode}
\array_new:N \l_hobby_controlb_array
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_matrix_v_fp}
% \Verb+\l_hobby_matrix_v_fp+ is a number which is used when doing the perturbation of the solution of the linear system for a closed curve.
% There is actually a vector, \(v\), that this corresponds to but that vector only has one component that needs computation.
%    \begin{macrocode}
\fp_new:N \l_hobby_matrix_v_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_tempa_fp}
% \Verb+\l_hobby_tempa_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempa_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_tempb_fp}
% \Verb+\l_hobby_tempb_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempb_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_tempc_fp}
% \Verb+\l_hobby_tempc_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempc_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_tempd_fp}
% \Verb+\l_hobby_tempd_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempd_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_temps_fp}
% \Verb+\l_hobby_temps_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_temps_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_in_curl_fp}
% \Verb+\l_hobby_in_curl_fp+ is the ``curl'' at the end of an open path.
% This is used if the angle at the end is not specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_in_curl_fp
\fp_set:Nn \l_hobby_in_curl_fp {1}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_out_curl_fp}
% \Verb+\l_hobby_out_curl_fp+ is the ``curl'' at the start of an open path.
% This is used if the angle at the start is not specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_out_curl_fp
\fp_set:Nn \l_hobby_out_curl_fp {1}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_in_angle_fp}
% \Verb+\l_hobby_in_angle_fp+ is the angle at the end of an open path.
% If this is not specified, it will be computed automatically.
% It is set to \Verb+\c_undefined_fp+ to allow easy detection of when it has been specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_in_angle_fp
\fp_set_eq:NN \l_hobby_in_angle_fp \c_undefined_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_out_angle_fp}
% \Verb+\l_hobby_out_angle_fp+ is the angle at the start of an open path.
% If this is not specified, it will be computed automatically.
% It is set to \Verb+\c_undefined_fp+ to allow easy detection of when it has been specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_out_angle_fp
\fp_set_eq:NN \l_hobby_out_angle_fp \c_undefined_fp
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\l_hobby_npoints_int}
% \Verb+\l_hobby_npoints_int+ is one less than the number of points on the curve.
% As our list of points starts at \(0\), this is the index of the last point.
% In the algorithm for a closed curve, some points are repeated whereupon this is incremented so that it is always the index of the last point. 
%    \begin{macrocode}
\int_new:N \l_hobby_npoints_int
%    \end{macrocode}
% \end{function}
%
% A ``point'' is a key-value list setting the x-value, the y-value, and the tensions at that point.
% Using keys makes it easier to pass points from the algorithm code to the calling code and vice versa without either knowing too much about the other.
%    \begin{macrocode}
\keys_define:nn {hobby / read in all} {
  x .fp_set:N = \l_hobby_tempa_fp,
  y .fp_set:N = \l_hobby_tempb_fp,
  tension~out .fp_set:N = \l_hobby_tempc_fp,
  tension~in .fp_set:N = \l_hobby_tempd_fp,
  excess~angle .fp_set:N = \l_hobby_temps_fp,
  tension .meta:n = { tension~out=#1, tension~in=#1 },
  tension~out .default:n = 1,
  tension~in .default:n = 1,
  excess~angle .default:n = 0,
  in~angle .fp_set:N = \l_hobby_in_angle_fp,
  out~angle .fp_set:N = \l_hobby_out_angle_fp,
  in~curl .fp_set:N = \l_hobby_in_curl_fp,
  out~curl .fp_set:N = \l_hobby_out_curl_fp,
  closed .bool_set:N = \l_hobby_closed_bool,
  closed .default:n = true,
  disjoint .bool_set:N = \l_hobby_disjoint_bool,
  disjoint .default:n = true,
}
%    \end{macrocode}
% There are certain other parameters than can be set for a give curve.
%    \begin{macrocode}
\keys_define:nn { hobby / read in params} {
  in~angle .fp_set:N = \l_hobby_in_angle_fp,
  out~angle .fp_set:N = \l_hobby_out_angle_fp,
  in~curl .fp_set:N = \l_hobby_in_curl_fp,
  out~curl .fp_set:N = \l_hobby_out_curl_fp,
  closed .bool_set:N = \l_hobby_closed_bool,
  closed .default:n = true,
  disjoint .bool_set:N = \l_hobby_disjoint_bool,
  disjoint .default:n = true,
}
%    \end{macrocode}
% \begin{function}{\hobby_distangle:n}
% Computes the distance and angle between successive points.
% The argument given is the index of the current point.
% Assumptions: the points are in \Verb+\l_hobby_points_x_array+ and \Verb+\l_hobby_points_y_array+ and the index of the last point is \Verb+\l_hobby_npoints_int+.
%    \begin{macrocode}
\cs_set:Nn \hobby_distangle:n {
  \fp_set:Nn \l_hobby_tempa_fp {
    (\array_get:Nn \l_hobby_points_x_array {#1 + 1})
    - (\array_get:Nn \l_hobby_points_x_array {#1})}

  \fp_set:Nn \l_hobby_tempb_fp {
    (\array_get:Nn \l_hobby_points_y_array {#1 + 1})
    - (\array_get:Nn \l_hobby_points_y_array {#1})}

  \fp_atantwo:NNN \l_hobby_tempc_fp \l_hobby_tempb_fp   \l_hobby_tempa_fp
  \fp_veclen:NVV \l_hobby_tempd_fp \l_hobby_tempa_fp \l_hobby_tempb_fp

  \array_push:Nx \l_hobby_angles_array {\fp_to_tl:N \l_hobby_tempc_fp}
  \array_push:Nx \l_hobby_distances_array {\fp_to_tl:N \l_hobby_tempd_fp}
  }
%    \end{macrocode}
% \end{function}
%
%
% \begin{function}{\fp_atantwo:NNN}
% Computes the angle of the point specified by the latter two arguments, storing the answer in the first.
% The inverse tangent function is not yet implemented in \LaTeX3 so for now we use the \Verb+pgfmath+ function.
% When this is implemented in \LaTeX3 this should be replaced.
%    \begin{macrocode}
\cs_new:Nn \fp_atantwo:NNN {
  \pgfmathparse{rad(atan2(\fp_use:N #3,\fp_use:N #2))}
  \exp_args:NNo \fp_set:Nn #1 {\pgfmathresult}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\fp_veclen:NVV}
% Computes the length of the vector specified by the latter two arguments, storing the answer in the first.
%    \begin{macrocode}
\cs_new:Nn \fp_veclen:Nnn {
  \fp_set:Nn #1 {((#2)^2 + (#3)^2)^.5}
}
\cs_generate_variant:Nn \fp_veclen:Nnn {NVV}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby_ctrllen:Nnn}
% Computes the length of the control point vector from the two angles, storing the answer in the first argument given.
%    \begin{macrocode}
\cs_new:Nn \hobby_ctrllen:Nnn {
  \fp_set:Nn #1 {(2 - \g_hobby_parama_fp
    * ( sin(#2) - \g_hobby_paramb_fp * sin(#3) )
    * ( sin(#3) - \g_hobby_paramb_fp * sin(#2) )
    * ( cos(#2) - cos(#3) ) )
    / ( 1 + (1 - \g_hobby_paramc_fp) * cos(#3) + \g_hobby_paramc_fp * cos(#2))}
}
\cs_generate_variant:Nn \hobby_ctrllen:Nnn {NVV}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby_append_point_copy:n}
%   This function adds a copy of the point (numbered by its argument) to the end of the list of points, copying all the relevant data  (coordinates, tension, etc.).
%
% Originally from Bruno Le Foch on TeX-SX.
%    \begin{macrocode}
\cs_new_protected:Npn \hobby_append_point_copy:n #1
  {
    \hobby_append_point_copy_aux:Nn \l_hobby_points_array {#1}
    \hobby_append_point_copy_aux:Nn \l_hobby_points_x_array {#1}
    \hobby_append_point_copy_aux:Nn \l_hobby_points_y_array {#1}
    \hobby_append_point_copy_aux:Nn \l_hobby_tension_in_array {#1}
    \hobby_append_point_copy_aux:Nn \l_hobby_tension_out_array {#1}
    \hobby_append_point_copy_aux:Nn \l_hobby_excess_angle_array {#1}
  }
\cs_new_protected:Npn \hobby_append_point_copy_aux:Nn #1#2
  { \array_push:Nx #1 { \array_get:Nn #1 {#2} } }
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby_genpath:}
% This is the curve generation function.
% We assume at the start that we have an array containing all the points that the curve must go through, and the various curve parameters have been initialised.
% So these must be set up by a wrapper function which then calls this one.
% The list of required information is:
% \begin{enumerate}
% \item \Verb+\l_hobby_points_x_array+
% \item \Verb+\l_hobby_points_y_array+
% \item \Verb+\l_hobby_tension_out_array+
% \item \Verb+\l_hobby_tension_in_array+
% \item \Verb+\l_hobby_excess_angle_array+
% \item \Verb+\l_hobby_in_curl_fp+
% \item \Verb+\l_hobby_out_curl_fp+
% \item \Verb+\l_hobby_in_angle_fp+
% \item \Verb+\l_hobby_out_angle_fp+
% \item \Verb+\l_hobby_closed_bool+
% \end{enumerate}
%
%    \begin{macrocode}
\cs_new:Nn \hobby_genpath:
{
%    \end{macrocode}
% For much of the time, we can pretend that a closed path is the same as an open path.
% To do this, we need to make the end node an internal node by repeating the \(z_1\) node as the \(z_{n+1}\)th node.
% We also check that the last (\(z_n\)) and first (\(z_0\)) nodes are the same, otherwise we repeat the \(z_0\) node as well.
%    \begin{macrocode}
\bool_if:NT \l_hobby_closed_bool {
%    \end{macrocode}
% Are the \(x\)-values of the first and last points different?
%    \begin{macrocode}
  \fp_compare:nTF {(\array_get:Nn \l_hobby_points_x_array {0})
    =
    (\array_top:N \l_hobby_points_x_array)}
  {
%    \end{macrocode}
% No, so compare the \(y\)-values.
% Are the \(y\)-values of the first and last points different?
%    \begin{macrocode}
    \fp_compare:nF {
      \array_get:Nn \l_hobby_points_y_array {0}
      =
      \array_top:N \l_hobby_points_y_array
    }
  {
%    \end{macrocode}
% Yes, so we need to duplicate the first point, with all of its data.
%    \begin{macrocode}
    \hobby_append_point_copy:n {0}
  }
  }
  {
%    \end{macrocode}
% Yes, so we need to duplicate the first point, with all of its data.
%    \begin{macrocode}
    \hobby_append_point_copy:n {0}
  }
%    \end{macrocode}
% Now that we are sure that the first and last points are identical, we need to duplicate the first-but-one point (and all of its data).
%    \begin{macrocode}
    \hobby_append_point_copy:n {1}
}
%    \end{macrocode}
%
% Set \Verb+\l_hobby_npoints_int+ to the number of points (minus one).
%    \begin{macrocode}
\int_set:Nn \l_hobby_npoints_int {\array_length:N \l_hobby_points_y_array}
%    \end{macrocode}
% 
% Our first step is to go through the list of points and compute the distances and angles between successive points.
% Thus \(d_i\) is the distance from \(z_i\) to \(z_{i+1}\) and the angle is the angle of the line from \(z_i\) to \(z_{i+1}\).

%    \begin{macrocode}
\prg_stepwise_function:nnnN {0} {1} {\l_hobby_npoints_int - 1} \hobby_distangle:n
%    \end{macrocode}
%
% For the majority of the code, we're only really interested in the differences of the angles.
% So for each internal point we compute the differences in the angles.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \fp_set:Nx \l_hobby_tempa_fp {
    \array_get:Nn \l_hobby_angles_array {##1}
    - \array_get:Nn \l_hobby_angles_array {##1 - 1}}
%    \end{macrocode}
% We want to ensure that these angles lie in the range \((-\pi,\pi]\).
% So if the angle is bigger than \(\pi\), we subtract \(2 \pi\).
% (It shouldn't be that we can get bigger than \(3 \pi\) - check this.)
%    \begin{macrocode}
    \fp_compare:nTF {\l_hobby_tempa_fp > \c_pi_fp }
    {
      \fp_sub:Nn \l_hobby_tempa_fp {2 * \c_pi_fp}
    }
    {}
%    \end{macrocode}
% Similarly, we check to see if the angle is less than \(-\pi\).
%    \begin{macrocode}
    \fp_compare:nTF {\l_hobby_tempa_fp < -\c_pi_fp }
    {
      \fp_add:Nn \l_hobby_tempa_fp {2 * \c_pi_fp}
    }
    {}
%    \end{macrocode}
% At the moment, the mixing of \Verb+pgfmath+ and \LaTeX3 that goes into computing the differences means that we can never get \Verb+\c_pi_fp+ so testing for equality is meaningless.
% However, when \Verb+atan2+ is implemented in \LaTeX3 then this might make sense again.
%
%^^A    \fp_compare:nTF {\l_hobby_tempa_fp = -\c_pi_fp }
%^^A    {
%^^A      \fp_add:Nn \l_hobby_tempa_fp {2 * \c_pi_fp}
%^^A    }
%^^A    {}
%
% The wrapping routine might not get it right at the edges so we add in the override.  
%    \begin{macrocode}
\array_get:NnNTF \l_hobby_excess_angle_array {##1} \l_tmpa_tl {
  \fp_add:Nn \l_hobby_tempa_fp {2 * \c_pi_fp * \l_tmpa_tl}
  }{}
%    \end{macrocode}
%    \begin{macrocode}
    \array_put:Nnx \l_hobby_psi_array {##1}{\fp_to_tl:N \l_hobby_tempa_fp}
  }
%    \end{macrocode}
%
% Next, we generate the matrix.
% We start with the subdiagonal.
% This is indexed from \(1\) to \(n-1\).
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \array_put:Nnx \l_hobby_matrix_a_array {##1} {\fp_to_tl:n {
       \array_get:Nn \l_hobby_tension_in_array {##1}^2
      * \array_get:Nn \l_hobby_distances_array {##1}
      * \array_get:Nn \l_hobby_tension_in_array {##1 + 1}
  }}
}
%    \end{macrocode}
%
% Next, we attack main diagonal.
% We might need to adjust the first and last terms, but we'll do that in a minute.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {

  \array_put:Nnx \l_hobby_matrix_b_array {##1} {\fp_to_tl:n
{(3 * (\array_get:Nn \l_hobby_tension_in_array {##1 + 1}) - 1) * 
 (\array_get:Nn \l_hobby_tension_out_array {##1})^2 * 
(\array_get:Nn \l_hobby_tension_out_array {##1 - 1})
* ( \array_get:Nn \l_hobby_distances_array {##1 - 1})
+
(3 * (\array_get:Nn \l_hobby_tension_out_array {##1 - 1}) - 1)
* (\array_get:Nn \l_hobby_tension_in_array {##1})^2
* (\array_get:Nn \l_hobby_tension_in_array {##1 + 1})
* (\array_get:Nn \l_hobby_distances_array {##1})}
}
}
%    \end{macrocode}
%
% Next, the superdiagonal.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 2} {

  \array_put:Nnx \l_hobby_matrix_c_array {##1} {\fp_to_tl:n
{(\array_get:Nn \l_hobby_tension_in_array {##1})^2
* (\array_get:Nn \l_hobby_tension_in_array {##1 - 1})
* (\array_get:Nn \l_hobby_distances_array {##1 - 1})
}}

}
%    \end{macrocode}
%
% Lastly (before the adjustments), the target vector.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 2} {

  \array_put:Nnx \l_hobby_matrix_d_array {##1} {\fp_to_tl:n
{
- (\array_get:Nn \l_hobby_psi_array {##1 + 1})
* (\array_get:Nn \l_hobby_tension_out_array {##1})^2
* (\array_get:Nn \l_hobby_tension_out_array {##1 - 1})
* (\array_get:Nn \l_hobby_distances_array {##1 - 1})
- (3 * (\array_get:Nn \l_hobby_tension_out_array {##1 - 1}) - 1)
* (\array_get:Nn \l_hobby_psi_array {##1})
* (\array_get:Nn \l_hobby_tension_in_array {##1})^2
* (\array_get:Nn \l_hobby_tension_in_array {##1 + 1})
* (\array_get:Nn \l_hobby_distances_array {##1})
}
}
}
%    \end{macrocode}
%
% Next, there are some adjustments at the ends.
% These differ depending on whether the path is open or closed.
%    \begin{macrocode}
\bool_if:NTF \l_hobby_closed_bool {
%    \end{macrocode}
% Closed path
%    \begin{macrocode}
\array_put:Nnx \l_hobby_matrix_c_array {0} {\fp_to_tl:n {
- (\array_get:Nn \l_hobby_distances_array {\l_hobby_npoints_int - 2})
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 2})
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 1})^2
}}

\array_put:Nnn \l_hobby_matrix_b_array {0} {1}
\array_put:Nnn \l_hobby_matrix_d_array {0} {0}

\array_put:Nnx \l_hobby_matrix_b_array {\l_hobby_npoints_int - 1} {\fp_to_tl:n {
(\array_get:Nn \l_hobby_matrix_b_array {\l_hobby_npoints_int - 1})
+ 1 
}}

 \array_put:Nnx \l_hobby_matrix_d_array {\l_hobby_npoints_int - 1} {\fp_to_tl:n {
- (\array_get:Nn \l_hobby_psi_array {1})
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int -1})^2
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int -2})
* (\array_get:Nn \l_hobby_distances_array {\l_hobby_npoints_int - 2})
- (3 * (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 2}) - 1)
* (\array_get:Nn \l_hobby_psi_array {\l_hobby_npoints_int - 1})
* (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int - 1})^2
* (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int})
* (\array_get:Nn \l_hobby_distances_array {\l_hobby_npoints_int -1})
}
}
%    \end{macrocode}
% We also need to populate the \(u\)-vector
%    \begin{macrocode}
  \array_put:Nnn \l_hobby_vector_u_array {0} {1}
\array_put:Nnn \l_hobby_vector_u_array {\l_hobby_npoints_int - 1} {1}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 2} {
  \array_put:Nnn \l_hobby_vector_u_array {##1} {0}
  }
%    \end{macrocode}
% And define the significant entry in the \(v\)-vector.
%    \begin{macrocode}
\fp_set:Nn \l_hobby_matrix_v_fp {
(\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int -1})^2
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int -2})
* (\array_get:Nn \l_hobby_distances_array {\l_hobby_npoints_int -2})
}
}
{
%    \end{macrocode}
% Open path.
% First, we test to see if \(\theta_0\) has been specified.
%    \begin{macrocode}
\fp_if_undefined:NTF \l_hobby_out_angle_fp
{
  \array_put:Nnx \l_hobby_matrix_b_array {0}  {\fp_to_tl:n {
  (\array_get:Nn \l_hobby_tension_in_array {1})^3
* \l_hobby_in_curl_fp
+
(3 * (\array_get:Nn \l_hobby_tension_in_array {1}) - 1)
* (\array_get:Nn \l_hobby_tension_out_array {0})^3
}}

  \array_put:Nnx \l_hobby_matrix_c_array {0} {\fp_to_tl:n {
  (\array_get:Nn \l_hobby_tension_out_array {0})^3
+
(3 * (\array_get:Nn \l_hobby_tension_out_array {0}) - 1)
* (\array_get:Nn \l_hobby_tension_in_array {1})^3
* \l_hobby_in_curl_fp
}}

  \array_put:Nnx \l_hobby_matrix_d_array {0} {\fp_to_tl:n {
-(  (\array_get:Nn \l_hobby_tension_out_array {0})^3
+
(3 * (\array_get:Nn \l_hobby_tension_out_array {0}) - 1)
* (\array_get:Nn \l_hobby_tension_in_array {1})^3
* \l_hobby_in_curl_fp)
* (\array_get:Nn \l_hobby_psi_array {1})
}}
  
}
{
  \array_put:Nnn \l_hobby_matrix_b_array {0} {1}
  \array_put:Nnn \l_hobby_matrix_c_array {0} {0}
  \fp_set:Nn \l_hobby_tempa_fp { \l_hobby_out_angle_fp
    - \array_get:Nn \l_hobby_angles_array {0} }
%    \end{macrocode}
% We want to ensure that these angles lie in the range \((-\pi,\pi]\).
% So if the angle is bigger than \(\pi\), we subtract \(2 \pi\).
% (It shouldn't be that we can get bigger than \(3 \pi\) - check this)
%    \begin{macrocode}
    \fp_compare:nT {\l_hobby_tempa_fp > \c_pi_fp }
    {
      \fp_sub:Nn \l_hobby_tempa_fp {2 * \c_pi_fp}
    }
%    \end{macrocode}
% Similarly, we check to see if the angle is less than \(-\pi\).
%    \begin{macrocode}
    \fp_compare:nT {\l_hobby_tempa_fp < -\c_pi_fp }
    {
      \fp_add:Nn \l_hobby_tempa_fp {2 * \c_pi_fp}
    }
  \array_put:Nnx \l_hobby_matrix_d_array {0} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Next, if \(\phi_n\) has been given.
%    \begin{macrocode}
\fp_if_undefined:NTF \l_hobby_in_angle_fp
{

 \array_put:Nnx \l_hobby_matrix_b_array {\l_hobby_npoints_int - 1} {\fp_to_tl:n {
\array_get:Nn \l_hobby_matrix_b_array {\l_hobby_npoints_int - 1}
- (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 1})^2
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 2})
* (\array_get:Nn \l_hobby_distances_array {\l_hobby_npoints_int - 2})
*
((3 * (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int} ) - 1)
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 1})^3 \l_tmpa_tl
* \l_hobby_out_curl_fp
+
(\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int })^3)
/
((3 * (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int -2}) - 1)
* (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int})^3
+
( \array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 1})^3
* \l_hobby_out_curl_fp)
}}

 \array_put:Nnx \l_hobby_matrix_d_array {\l_hobby_npoints_int - 1} {\fp_to_tl:n {
- (3 * (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 2}) - 1)
* (\array_get:Nn \l_hobby_psi_array {\l_hobby_npoints_int - 1})
* (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int - 1})^2
* (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int})
* (\array_get:Nn \l_hobby_distances_array {\l_hobby_npoints_int - 1})
}}

}
{
  \fp_set:Nn \l_hobby_tempa_fp { - \l_hobby_in_angle_fp + \c_pi_fp
+ (\array_get:Nn \l_hobby_angles_array {\l_hobby_npoints_int - 1})}
  \fp_compare:nT {\l_hobby_tempa_fp > \c_pi_fp }
  {
    \fp_sub:Nn \l_hobby_tempa_fp {2 * \c_pi_fp}
  }
  \fp_compare:nT {\l_hobby_tempa_fp < -\c_pi_fp }
  {
    \fp_add:Nn \l_hobby_tempa_fp {2 * \c_pi_fp}
  }

  \array_put:Nnx \l_hobby_phi_array {\l_hobby_npoints_int}
  {\fp_to_tl:N \l_hobby_tempa_fp}

   \array_put:Nnx \l_hobby_matrix_d_array  {\l_hobby_npoints_int - 1} {\fp_to_tl:n {
 \l_hobby_tempa_fp
 * (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 1})^2
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 2})
* (\array_get:Nn \l_hobby_distances_array {\l_hobby_npoints_int - 2})
-
(3 * ( \array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 2}) - 1)
* (\array_get:Nn \l_hobby_psi_array {\l_hobby_npoints_int - 1})
* (\array_get:Nn \l_hobby_tension_in_array  {\l_hobby_npoints_int - 1})^2
* (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int})
* (\array_get:Nn \l_hobby_distances_array  {\l_hobby_npoints_int - 1}) }}
}
%    \end{macrocode}
% End of adjustments for open paths.
%    \begin{macrocode}
}
%    \end{macrocode}
%
% Now we have the tridiagonal matrix in place, we implement the solution.
% We start with the forward eliminations.
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {

  \array_put:Nnx \l_hobby_matrix_b_array {##1} {\fp_to_tl:n {
  (\array_get:Nn \l_hobby_matrix_b_array {##1 - 1})
* (\array_get:Nn \l_hobby_matrix_b_array {##1})
-
(\array_get:Nn \l_hobby_matrix_c_array {##1 - 1})
* (\array_get:Nn \l_hobby_matrix_a_array {##1})
}}
%    \end{macrocode}
% The last time, we don't touch the \(C\)-vector.
%    \begin{macrocode}
  \int_compare:nT {##1 < \l_hobby_npoints_int - 1} {

  \array_put:Nnx \l_hobby_matrix_c_array {##1} {\fp_to_tl:n {
(\array_get:Nn \l_hobby_matrix_b_array {##1 - 1})
    * (\array_get:Nn \l_hobby_matrix_c_array {##1})
}}
  }

  \array_put:Nnx \l_hobby_matrix_d_array {##1} {\fp_to_tl:n {
(\array_get:Nn \l_hobby_matrix_b_array {##1 - 1})
  * (\array_get:Nn \l_hobby_matrix_d_array {##1})
-
  (\array_get:Nn \l_hobby_matrix_d_array {##1 - 1})
  * (\array_get:Nn \l_hobby_matrix_a_array {##1})
}}
%    \end{macrocode}
% On a closed path, we also want to know \(M^{-1} u\) so need to do the elimination steps on \(u\) as well.
%    \begin{macrocode}
  \bool_if:NT \l_hobby_closed_bool {
  \array_put:Nnx \l_hobby_vector_u_array {##1} {\fp_to_tl:n {
(\array_get:Nn \l_hobby_matrix_b_array {##1 - 1})
* (\array_get:Nn \l_hobby_vector_u_array {##1})
-
(\array_get:Nn \l_hobby_vector_u_array {##1 - 1})
* (\array_get:Nn \l_hobby_matrix_a_array {##1})
}}
}
}
%    \end{macrocode}
% Now we start the back substitution.
% The first step is slightly different to the general step.
%    \begin{macrocode}
 \array_put:Nnx \l_hobby_theta_array  {\l_hobby_npoints_int - 1} {\fp_to_tl:n {
(\array_get:Nn \l_hobby_matrix_d_array  {\l_hobby_npoints_int - 1})
/ (\array_get:Nn \l_hobby_matrix_b_array  {\l_hobby_npoints_int - 1})
}}
%    \end{macrocode}
% For a closed path, we need to work with \(u\) as well.
%    \begin{macrocode}
\bool_if:NT \l_hobby_closed_bool {
 \array_put:Nnx \l_hobby_vector_u_array  {\l_hobby_npoints_int - 1} {\fp_to_tl:n {
  (\array_get:Nn \l_hobby_vector_u_array  {\l_hobby_npoints_int - 1})
/ (\array_get:Nn \l_hobby_matrix_b_array  {\l_hobby_npoints_int - 1})
}}
}
%    \end{macrocode}
% Now we iterate over the vectors, doing the remaining back substitutions.
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {\l_hobby_npoints_int - 2} {-1} {0} {

  \array_put:Nnx \l_hobby_theta_array {##1} {\fp_to_tl:n {
( (\array_get:Nn \l_hobby_matrix_d_array {##1})
  - (\array_get:Nn \l_hobby_theta_array  {##1 + 1})
  * (\array_get:Nn \l_hobby_matrix_c_array {##1})
) / (\array_get:Nn \l_hobby_matrix_b_array {##1})
}}
}
\bool_if:NT \l_hobby_closed_bool {
%    \end{macrocode}
% On a closed path, we also need to work out \(M^{-1} u\).
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {\l_hobby_npoints_int - 2} {-1} {0} {
  \array_put:Nnx \l_hobby_vector_u_array {##1} {\fp_to_tl:n
{
    ((\array_get:Nn \l_hobby_vector_u_array {##1})
    - (\array_get:Nn \l_hobby_vector_u_array  {##1 + 1})
    * (\array_get:Nn \l_hobby_matrix_c_array {##1})
    ) / (\array_get:Nn \l_hobby_matrix_b_array {##1})
}}
}
%    \end{macrocode}
% Then we compute \(v^\top M^{-1}u\) and \(v^\top M^{-1} \theta\).
% As \(v\) has a particularly simple form, these inner products are easy to compute.
%    \begin{macrocode}

\fp_set:Nn \l_hobby_tempb_fp {
((\array_get:Nn \l_hobby_theta_array {1})
* \l_hobby_matrix_v_fp
- (\array_get:Nn \l_hobby_theta_array  {\l_hobby_npoints_int - 1})
) / (
(\array_get:Nn \l_hobby_vector_u_array {1})
* \l_hobby_matrix_v_fp
- (\array_get:Nn \l_hobby_vector_u_array  {\l_hobby_npoints_int - 1})
+ 1
)}

\prg_stepwise_inline:nnnn {0} {1} {\l_hobby_npoints_int - 1} {

  \array_put:Nnx \l_hobby_theta_array {##1} {\fp_to_tl:n {
  (\array_get:Nn \l_hobby_theta_array {##1})
  - (\array_get:Nn \l_hobby_vector_u_array {##1})
  * \l_hobby_tempb_fp
}}
}
}
%    \end{macrocode}
%
% Now that we have computed the \(\theta_i\)s, we can quickly compute the \(\phi_i\)s.
%
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {

    \array_put:Nnx \l_hobby_phi_array {##1} {\fp_to_tl:n {
      - (\array_get:Nn \l_hobby_psi_array {##1})
      - (\array_get:Nn \l_hobby_theta_array {##1})
  }}
  }
%    \end{macrocode}
%
% If the path is open, this works for all except \(\phi_n\).
% If the path is closed, we can drop our added point.
% Cheaply, of course.
%    \begin{macrocode}
\bool_if:NTF \l_hobby_closed_bool {
  \int_decr:N \l_hobby_npoints_int
}{
%    \end{macrocode}
% If \(\phi_n\) was not given, we compute it from \(\theta_{n-1}\).
%    \begin{macrocode}
\fp_if_undefined:NT \l_hobby_in_angle_fp
{
 \array_put:Nnx \l_hobby_phi_array {\l_hobby_npoints_int} {\fp_to_tl:n {
((3 * (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int}) - 1)
* (\array_get:Nn \l_hobby_tension_out_array {\l_hobby_npoints_int - 1})^3
* \l_hobby_out_curl_fp
+
(\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int })^3)
/
((3 * (\array_get:Nn \l_hobby_tension_out_array  {\l_hobby_npoints_int -2}) - 1)
* (\array_get:Nn \l_hobby_tension_in_array {\l_hobby_npoints_int})^3 \l_tmpa_tl
+
(\array_get:Nn \l_hobby_tension_out_array  {\l_hobby_npoints_int - 1})^3
* \l_hobby_out_curl_fp)
*
(\array_get:Nn \l_hobby_theta_array  {\l_hobby_npoints_int -1})
}}
}
}
%    \end{macrocode}
%
% Next task is to compute the \(\rho_i\) and \(\sigma_i\).
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {0} {1} {\l_hobby_npoints_int - 1} {

  \fp_set:Nn \l_hobby_tempa_fp {\array_get:Nn \l_hobby_theta_array {##1}}

  \fp_set:Nn \l_hobby_tempb_fp {\array_get:Nn \l_hobby_phi_array  {##1 + 1}}

  \hobby_ctrllen:NVV \l_hobby_temps_fp \l_hobby_tempa_fp \l_hobby_tempb_fp

   \array_put:Nnx \l_hobby_sigma_array {##1 + 1} {\fp_to_tl:N \l_hobby_temps_fp}

  \hobby_ctrllen:NVV \l_hobby_temps_fp \l_hobby_tempb_fp \l_hobby_tempa_fp

   \array_put:Nnx \l_hobby_rho_array {##1} {\fp_to_tl:N \l_hobby_temps_fp}

  }
%    \end{macrocode}
% Lastly, we generate the coordinates of the control points.
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {0} {1} {\l_hobby_npoints_int - 1} {

\array_put:Nnx \l_hobby_controla_array  {##1 + 1} {x = \fp_eval:n  {
(\array_get:Nn \l_hobby_points_x_array {##1})
+
  (\array_get:Nn \l_hobby_distances_array {##1}) *
  (\array_get:Nn \l_hobby_rho_array {##1}) *
cos ( (\array_get:Nn \l_hobby_angles_array {##1})
+
  (\array_get:Nn \l_hobby_theta_array {##1}))
/3
}, y = \fp_eval:n {
( \array_get:Nn \l_hobby_points_y_array {##1}) +
  (\array_get:Nn \l_hobby_distances_array {##1}) *
  (\array_get:Nn \l_hobby_rho_array {##1}) *
sin ( (\array_get:Nn \l_hobby_angles_array {##1})
+
  (\array_get:Nn \l_hobby_theta_array {##1}))
/3
}
}
}

\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int} {
  \array_put:Nnx \l_hobby_controlb_array {##1} {
    x = \fp_eval:n {\array_get:Nn \l_hobby_points_x_array {##1}
- (\array_get:Nn \l_hobby_distances_array  {##1 - 1})
* (\array_get:Nn \l_hobby_sigma_array {##1})
* cos((\array_get:Nn \l_hobby_angles_array  {##1 - 1})
- (\array_get:Nn \l_hobby_phi_array {##1}))/3
}, y = \fp_eval:n {
  (\array_get:Nn \l_hobby_points_y_array {##1})
- (\array_get:Nn \l_hobby_distances_array  {##1 - 1})
* (\array_get:Nn \l_hobby_sigma_array {##1})
* sin((\array_get:Nn \l_hobby_angles_array  {##1 - 1})
- (\array_get:Nn \l_hobby_phi_array {##1}))/3
} }
 }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobbyinit}
% Initialise the settings for Hobby's algorithm
%    \begin{macrocode}
\NewDocumentCommand \hobbyinit {m m m} {
\hobby_set_cmds:nnn#1#2#3
\array_clear:N \l_hobby_points_array
\array_clear:N \l_hobby_points_x_array
\array_clear:N \l_hobby_points_y_array
\array_clear:N \l_hobby_angles_array
\array_clear:N \l_hobby_distances_array
\array_clear:N \l_hobby_tension_out_array
\array_clear:N \l_hobby_tension_in_array
\array_clear:N \l_hobby_excess_angle_array
\array_clear:N \l_hobby_matrix_a_array
\array_clear:N \l_hobby_matrix_b_array
\array_clear:N \l_hobby_matrix_c_array
\array_clear:N \l_hobby_matrix_d_array
\array_clear:N \l_hobby_vector_u_array
\array_clear:N \l_hobby_psi_array
\array_clear:N \l_hobby_theta_array
\array_clear:N \l_hobby_phi_array
\array_clear:N \l_hobby_sigma_array
\array_clear:N \l_hobby_rho_array
\array_clear:N \l_hobby_controla_array
\array_clear:N \l_hobby_controlb_array
\bool_set_false:N \l_hobby_closed_bool
\bool_set_false:N \l_hobby_disjoint_bool

  \int_set:Nn \l_hobby_npoints_int {-1}
  \fp_set_eq:NN \l_hobby_in_angle_fp \c_undefined_fp
  \fp_set_eq:NN \l_hobby_out_angle_fp \c_undefined_fp
  \fp_set_eq:NN \l_hobby_in_curl_fp \c_one_fp
  \fp_set_eq:NN \l_hobby_out_curl_fp \c_one_fp
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobbyaddpoint}
% This adds a point, possibly with tensions, to the current stack.
%    \begin{macrocode}
\NewDocumentCommand \hobbyaddpoint { m } {
    \keys_set:nn { hobby/read in all }
    {
      tension~out,
      tension~in,
      excess~angle,
      #1
    }
    \array_push:Nx \l_hobby_tension_out_array {\fp_to_tl:N \l_hobby_tempc_fp}
    \array_push:Nx \l_hobby_tension_in_array {\fp_to_tl:N \l_hobby_tempd_fp}
    \array_push:Nx \l_hobby_excess_angle_array {\fp_to_tl:N \l_hobby_temps_fp}
    \array_push:Nx \l_hobby_points_array {
      x = \fp_use:N \l_hobby_tempa_fp,
      y = \fp_use:N \l_hobby_tempb_fp }
    \array_push:Nx \l_hobby_points_x_array {\fp_to_tl:N \l_hobby_tempa_fp}
    \array_push:Nx \l_hobby_points_y_array {\fp_to_tl:N \l_hobby_tempb_fp}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobbysetparams}
% This sets the parameters for the curve.
%    \begin{macrocode}
\NewDocumentCommand \hobbysetparams { m } {
  \keys_set:nn { hobby / read in params }
  {
    #1
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby_set_cmds:nnn}
% The path-generation code doesn't know what to actually do with the path so the initialisation code will set some macros to do that.
% This is an auxiliary command that sets these macros.
%    \begin{macrocode}
\cs_new:Nn \hobby_set_cmds:nnn {
  \cs_set_eq:NN \hobby_moveto:n #1
  \cs_set_eq:NN \hobby_curveto:nnn #2
  \cs_set_eq:NN \hobby_close:n #3
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\hobbygenpath}
% This is the user (well, sort of) command that generates and uses the curve.
%    \begin{macrocode}
\tl_new:N \l_tmpc_tl
\NewDocumentCommand \hobbygenpath { } {
  \hobby_genpath:
  \bool_if:NT \l_hobby_disjoint_bool {
    \array_get:NnN \l_hobby_points_array {0} \l_tmpa_tl
    \exp_args:No \hobby_moveto:n {\l_tmpa_tl}
  }
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int} {
    \array_get:NnN \l_hobby_controla_array {##1} \l_tmpa_tl
    \array_get:NnN \l_hobby_controlb_array {##1} \l_tmpb_tl
    \array_get:NnN \l_hobby_points_array {##1} \l_tmpc_tl
    \exp_args:Nooo \hobby_curveto:nnn {\l_tmpa_tl} {\l_tmpb_tl} {\l_tmpc_tl}
}
  \bool_if:NT \l_hobby_closed_bool {
    \array_get:NnN \l_hobby_points_array {0} \l_tmpa_tl
    \exp_args:No \hobby_close:n {\l_tmpa_tl}
    }
}
%    \end{macrocode}
% \end{function}
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
% \iffalse
%</hobby>
% \fi
%
% \subsection{PGF Library}
%
% \iffalse
%<*pgflibrary>
% \fi
% 
% The PGF level is very simple.
% All we do is set up the path-construction commands that get passed to the path-generation function.
%    \begin{macrocode}
\input{hobby.code.tex}
%    \end{macrocode}
% Points are communicated as key-pairs.
% These keys translate from the \LaTeX3 style points to PGF points.
%    \begin{macrocode}
\pgfkeys{
  /pgf/hobby/.is family,
  /pgf/hobby/.cd,
  x/.code={\pgf@x=#1cm},
  y/.code={\pgf@y=#1cm},
}
%    \end{macrocode}
% \begin{function}{\hobby@curveto}
% This is passed to the path-generation code to translate the path into a PGF path.
%    \begin{macrocode}
\def\hobby@curveto#1#2#3{%
  \pgfpathcurveto{\hobby@topgf{#1}}{\hobby@topgf{#2}}{\hobby@topgf{#3}}%
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@moveto}
% This is passed to the path-generation code to translate the path into a PGF path.
%    \begin{macrocode}
\def\hobby@moveto#1{%
  \pgfpathmoveto{\hobby@topgf{#1}}%
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@topgf}
% Translates a \LaTeX3 point to a PGF point.
%    \begin{macrocode}
\def\hobby@topgf#1{%
    \pgfqkeys{/pgf/hobby}{#1}%
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@close}
% Closes a path.
%    \begin{macrocode}
\def\hobby@close#1{%
  \pgfpathclose
}
%    \end{macrocode}
% \end{function}
% \iffalse
%</pgflibrary>
% \fi
%
% \subsection{TikZ Library}
%
% \iffalse
%<*tikzlibrary>
% \fi
% 
%    \begin{macrocode}
\usepgflibrary{hobby}
\let\hobby@opts=\pgfutil@empty
%    \end{macrocode}
%
% We set various TikZ keys.
% These include the \Verb+to path+ constructor and all the various parameters that will eventually get passed to the path-generation code.
%    \begin{macrocode}
\tikzset{
  curve through/.style={
    to path={
      \pgfextra{
        \expandafter\curvethrough\expandafter[\hobby@opts]{%
          (\tikztostart) .. #1 .. (\tikztotarget)%
        }
      }
    }
  },
  tension in/.code = {},
  tension out/.code = {},
  tension/.code = {},
  excess angle/.code = {},
  closed/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts%
      closed=#1,disjoint=#1}%
  },
  closed/.default = true,
  in angle/.code = {%
    \pgfmathparse{#1*pi/180}%
    \edef\@temp{ in angle=\pgfmathresult,}%
    \expandafter\expandafter\expandafter%
    \def%
    \expandafter\expandafter\expandafter%
    \hobby@opts%
    \expandafter\expandafter\expandafter%
    {\expandafter\hobby@opts\@temp}%
  },
  out angle/.code = {%
    \pgfmathparse{#1*pi/180}%
    \edef\@temp{ out angle=\pgfmathresult,}%
    \expandafter\expandafter\expandafter%
    \def%
    \expandafter\expandafter\expandafter%
    \hobby@opts%
    \expandafter\expandafter\expandafter%
    {\expandafter\hobby@opts\@temp}%
  },
  in curl/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts in curl=#1,}%
  },
  out curl/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts out curl=#1,}%
  },
  use Hobby shortcut/.code={%
    \let\tikz@curveto@auto=\hobby@curveto@auto
  }
}
%    \end{macrocode}
% \begin{function}{\curvethrough}
% This is the parent command.
% We initialise the path-generation code, set any parameters, and then hand over control to the point processing macro.
%    \begin{macrocode}
\newcommand\curvethrough[2][]{%
  \hobbyinit\hobby@moveto\hobby@curveto\hobby@close
  \hobbysetparams{#1}%
  \hobby@processpts{#2}%
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@processpts}
% This processes a list of points in the format \Verb+(0,0) .. (1,1)+.
% Each point is scanned by TikZ and then added to the stack to be built into the path.
% If there are any remaining points, we call ourself again with them.
% Otherwise, we hand over control to the path-generation code.
%    \begin{macrocode}
\newcommand\hobby@processpts[1]{%
  \pgfutil@in@{..}{#1}%
  \ifpgfutil@in@%
    \hobby@getonepoint #1 \relax
    \let\hobby@next=\hobby@processpts
  \else
    \def\hobby@pt{#1}%
    \def\hobby@rest{}%
    \let\hobby@next=\hobbygenpath
  \fi
  \let\tikz@scan@point@options=\pgfutil@empty
  \expandafter\tikz@scan@one@point\expandafter\pgfutil@firstofone\hobby@pt\relax
  \pgfmathsetmacro\hobby@x{\the\pgf@x/1cm}%
  \pgfmathsetmacro\hobby@y{\the\pgf@y/1cm}%
  \expandafter\hobbyaddpoint\expandafter{\tikz@scan@point@options,%
    x = \hobby@x, y = \hobby@y}%
  \expandafter\hobby@next\expandafter{\hobby@rest}%
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@onepoint}
% This strips off the next point.
%    \begin{macrocode}
\def\hobby@getonepoint#1..#2\relax{%
  \def\hobby@pt{#1}%
  \def\hobby@rest{#2}%
}
%    \end{macrocode}
% \end{function}
%
% There is a ``spare hook'' in the TikZ path processing code.
% If TikZ encounters a path of the form \Verb+(0,0) .. (1,1)+ then it calls a macro \Verb+\tikz@curveto@auto+.
% However, that macro is not defined in the TikZ code.
% The following code provides a suitable definition.
% To play nice, we don't install it by default but define a key (defined above) that installs it.
% \begin{function}{\hobby@curveto@auto}
% When we're called by TikZ, we initialise the path generation code and start adding points.
% We want to be sure that we're only called once so we don't had control back to TikZ but use our own parser to process the rest of the curve until we reach a syntax that we don't understand.
%    \begin{macrocode}
\def\hobby@curveto@auto{%
  \hobbyinit\pgfutil@gobble\hobby@curveto\hobby@close
  \pgfmathsetmacro\hobby@x{\the\tikz@lastx/1cm}%
  \pgfmathsetmacro\hobby@y{\the\tikz@lasty/1cm}%
  \pgfutil@ifundefined{tikz@scan@point@options}{%
    \hobbyaddpoint{x = \hobby@x, y = \hobby@y}%
  }{%
  \expandafter\hobbyaddpoint\expandafter{\tikz@scan@point@options,%
      x = \hobby@x, y = \hobby@y}%
  }%
  \let\tikz@scan@point@options=\pgfutil@empty
  \tikz@scan@one@point\hobby@addfromtikz}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@addfromtikz}
% This adds our current point to the stack.
%    \begin{macrocode}
\def\hobby@addfromtikz#1{%
  #1%
  \tikz@make@last@position{#1}%
  \pgfmathsetmacro\hobby@x{\the\pgf@x/1cm}%
  \pgfmathsetmacro\hobby@y{\the\pgf@y/1cm}%
  \expandafter\hobbyaddpoint\expandafter{\tikz@scan@point@options,%
    x = \hobby@x, y = \hobby@y}%
  \hobby@donext}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@donext}
% Now we look to see if the next character is a dot.
% If not, we're done so generate the path.
%    \begin{macrocode}
\def\hobby@donext{%
  \pgfutil@ifnextchar.%
  {\hobby@curveto@check}%
  {\hobby@finish@auto}}%
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@curveto@check}
% It was a dot, so look at what comes after.
% It might be \Verb+.. c+ in which case we might be done.
% If not, we assume we're still adding points.
%    \begin{macrocode}
\def\hobby@curveto@check..{%
  \pgfutil@ifnextchar c%
  {\hobby@maybefinish@auto}%
  {\hobby@curveto@continue}}%
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@maybefinish@auto}
% We got \Verb+.. c+.
% It might be \Verb+.. controls+ in which case we're done.
% It might be \Verb+.. cycle+ in which case we have a closed path, after which we're done.
%    \begin{macrocode}
\def\hobby@maybefinish@auto c{%
  \pgfutil@ifnextchar o%
  {\hobby@finish@auto .. c}%
  {\hobby@closeandfinish@auto}}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@closeandfinish@auto}
% We got \Verb+.. cycle+ so eat it, flag the path as closed, and generate it.
%    \begin{macrocode}
\def\hobby@closeandfinish@auto ycle{%
  \hobbysetparams{closed=true,disjoint=true}%
  \hobby@finish@auto%
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@curveto@continue}
% Scan next coordinate and repeat the cycle.
%    \begin{macrocode}
\def\hobby@curveto@continue{%
  \let\tikz@scan@point@options=\pgfutil@empty
  \tikz@scan@one@point\hobby@addfromtikz}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@finish@auto}
% Generate the path and then hand control back to TikZ.
%    \begin{macrocode}
\def\hobby@finish@auto{%
  \hobbygenpath
  \tikz@scan@next@command%
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{quick curve through}
% The \Verb+quick curve through+ is a \Verb+to path+ which does the ``quick'' version of Hobby's algorithm.
% The syntax is as with the \Verb+curve through+: to pass the midpoints as the argument to the style.
% We need to pass three points to the auxiliary macro.
% These are passed as \Verb+\hobby@qpoints+, \Verb+\hobby@qpointa+, and the current point.
% Then these get cycled round for the next triple.
% The path gets built up and stored as \Verb+\hobby@quick@path+.
% We also have to remember the angle computed for the next round.
%    \begin{macrocode}
\tikzset{
  quick curve through/.style={%
    to path={%
      \pgfextra{%
%    \end{macrocode}
% Scan the starting point and store the coordinates in \Verb+\hobby@qpointa+
%    \begin{macrocode}
      \tikz@scan@one@point\pgfutil@firstofone(\tikztostart)%
        \edef\hobby@qpoints{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
%    \end{macrocode}
% Blank the path and auxiliary macros.
%    \begin{macrocode}
        \def\hobby@qpointa{}%
        \def\hobby@quick@path{}%
        \def\hobby@angle{}%
%    \end{macrocode}
% Now start parsing the rest of the coordinates.
%    \begin{macrocode}
        \tikz@scan@one@point\hobby@quickfirst #1 (\tikztotarget)\relax
      }
%    \end{macrocode}
% Invoke the path
%    \begin{macrocode}
      \hobby@quick@path
    }
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@sf}
% Working with points leads to computations out of range so we scale to get them into the computable arena.
%    \begin{macrocode}
\pgfmathsetmacro\hobby@sf{10cm}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@quickfirst}
% The first time around we just set the next point.
%    \begin{macrocode}
\def\hobby@quickfirst#1{%
  #1%
  \edef\hobby@qpointa{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
%    \end{macrocode}
% Now a check to ensure that we have more points.
%    \begin{macrocode}
  \pgfutil@ifnextchar\relax{%
%    \end{macrocode}
% Ooops, no more points.
% That's not good.
% Bail-out.
%    \begin{macrocode}
    \edef\hobby@quick@path{ -- (\the\pgf@x,\the\pgf@y)}%
  }{%
%    \end{macrocode}
% Okay, have more points.
% Phew.
% Call the next round.
%    \begin{macrocode}
    \tikz@scan@one@point\hobby@quick}}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\hobby@quick}
% This is the macro that does all the work of computing the control points.
%    \begin{macrocode}
\def\hobby@quick#1{%
%    \end{macrocode}
% Save the current (second - counting from zero) point in \Verb+\pgf@xb+ and \Verb+\pgf@yb+.
%    \begin{macrocode}
  #1%
  \pgf@xb=\pgf@x
  \pgf@yb=\pgf@y
%    \end{macrocode}
% Save the previous (first) point in \Verb+\pgf@xa+ and \Verb+\pgf@ya+.
%    \begin{macrocode}
  \hobby@qpointa
  \pgf@xa=\pgf@x
  \pgf@ya=\pgf@y
%    \end{macrocode}
% Adjust so that \Verb+(\pgf@xb,\pgf@yb)+ is the vector from second to third.
% Then compute and store the distance and angle of this vector.
% We view this as the vector \emph{from} the midpoint and everything to do with that point has the suffix \Verb+one+.
% Note that we divide by the scale factor here.
%    \begin{macrocode}
  \advance\pgf@xb by -\pgf@xa
  \advance\pgf@yb by -\pgf@ya
  \pgfmathsetmacro\hobby@done{sqrt((\pgf@xb/\hobby@sf)^2 + (\pgf@yb/\hobby@sf)^2)}%
  \pgfmathsetmacro\hobby@omegaone{rad(atan2(\pgf@xb,\pgf@yb))}%
%    \end{macrocode}
% Now we do the same with the vector from the zeroth to the first point.
%    \begin{macrocode}
  \hobby@qpoints
  \advance\pgf@xa by -\pgf@x
  \advance\pgf@ya by -\pgf@y
  \pgfmathsetmacro\hobby@dzero{sqrt((\pgf@xa/\hobby@sf)^2 + (\pgf@ya/\hobby@sf)^2)}%
  \pgfmathsetmacro\hobby@omegazero{rad(atan2(\pgf@xa,\pgf@ya))}%
%    \end{macrocode}
% \Verb+\hobby@psi+ is the angle subtended at the midpoint.
% We adjust to ensure that it is in the right range.
%    \begin{macrocode}
  \pgfmathsetmacro\hobby@psi{\hobby@omegaone - \hobby@omegazero}%
  \pgfmathsetmacro\hobby@psi{\hobby@psi > pi ? \hobby@psi - 2*pi : \hobby@psi}%
  \pgfmathsetmacro\hobby@psi{\hobby@psi < -pi ? \hobby@psi + 2*pi : \hobby@psi}%
%    \end{macrocode}
% Now we test to see if we're on the first run or not.
% If the first, we have no incoming angle.
%    \begin{macrocode}
  \ifx\hobby@angle\pgfutil@empty
%    \end{macrocode}
% First.
%    \begin{macrocode}
  \pgfmathsetmacro\hobby@thetaone{-\hobby@psi * \hobby@done%
/(\hobby@done + \hobby@dzero)}%
  \pgfmathsetmacro\hobby@thetazero{-\hobby@psi - \hobby@thetaone}%
  \let\hobby@phione=\hobby@thetazero
  \let\hobby@phitwo=\hobby@thetaone
  \else
%    \end{macrocode}
% Second or later.
%    \begin{macrocode}
  \let\hobby@thetazero=\hobby@angle
  \pgfmathsetmacro\hobby@thetaone{%
  -(2 * \hobby@psi + \hobby@thetazero) * \hobby@done%
  / (2 * \hobby@done + \hobby@dzero)}%
  \pgfmathsetmacro\hobby@phione{-\hobby@psi - \hobby@thetaone}%
  \let\hobby@phitwo=\hobby@thetaone
  \fi
%    \end{macrocode}
% Save the outgoing angle.
%    \begin{macrocode}
  \let\hobby@angle=\hobby@thetaone
%    \end{macrocode}
% Compute the control lengths.
%    \begin{macrocode}
  \pgfmathsetmacro\hobby@alpha{%
    sqrt(2) * (sin(\hobby@thetazero r) - 1/16 * sin(\hobby@phione r))%
* (sin(\hobby@phione r) - 1/16 * sin(\hobby@thetazero r))%
 * (cos(\hobby@thetazero r) - cos(\hobby@phione r))}%
  \pgfmathsetmacro\hobby@rho{%
    (2 + \hobby@alpha)/(1 + (1 - (3 - sqrt(5))/2)%
 * cos(\hobby@thetazero r) + (3 - sqrt(5))/2 * cos(\hobby@phione r))}%
  \pgfmathsetmacro\hobby@sigma{%
    (2 - \hobby@alpha)/(1 + (1 - (3 - sqrt(5))/2)%
  * cos(\hobby@phione r) +  (3 - sqrt(5))/2 * cos(\hobby@thetazero r))}%
%    \end{macrocode}
% Now compute the control points.
%    \begin{macrocode}
  \hobby@qpoints
  \pgf@xa=\pgf@x
  \pgf@ya=\pgf@y
  \pgfmathsetlength\pgf@xa{%
    \pgf@xa + \hobby@dzero * \hobby@rho%
  * cos((\hobby@thetazero + \hobby@omegazero) r)/3*\hobby@sf}%
  \pgfmathsetlength\pgf@ya{%
    \pgf@ya + \hobby@dzero * \hobby@rho%
  * sin((\hobby@thetazero + \hobby@omegazero) r)/3*\hobby@sf}%
  \hobby@qpointa
  \pgf@xb=\pgf@x
  \pgf@yb=\pgf@y
  \pgfmathsetlength\pgf@xb{%
    \pgf@xb - \hobby@dzero * \hobby@sigma%
  * cos((-\hobby@phione + \hobby@omegazero) r)/3*\hobby@sf}%
  \pgfmathsetlength\pgf@yb{%
    \pgf@yb - \hobby@dzero * \hobby@sigma%
  * sin((-\hobby@phione + \hobby@omegazero) r)/3*\hobby@sf}%
%    \end{macrocode}
% Now add the relevant part to the path.
%    \begin{macrocode}
  \hobby@qpointa
  \edef\hobby@quick@path{\hobby@quick@path .. controls%
  (\the\pgf@xa,\the\pgf@ya) and (\the\pgf@xb,\the\pgf@yb) .. (\the\pgf@x,\the\pgf@y) }%
%    \end{macrocode}
% Cycle the points round for the next iteration.
%    \begin{macrocode}
  \let\hobby@qpoints=\hobby@qpointa
  #1
  \edef\hobby@qpointa{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
%    \end{macrocode}
% Test to see if we have more points.
% If not, the next thing we see will be that \Verb+\relax+.
%    \begin{macrocode}
  \pgfutil@ifnextchar\relax{%
%    \end{macrocode}
% No more points.
% Compute the control points for the second part of the curve and add that to the path.
%    \begin{macrocode}
  \pgfmathsetmacro\hobby@alpha{%
    sqrt(2) * (sin(\hobby@thetaone r) - 1/16 * sin(\hobby@phitwo r))%
    * (sin(\hobby@phitwo r) - 1/16 * sin(\hobby@thetaone r))%
    * (cos(\hobby@thetaone r) - cos(\hobby@phitwo r))}%
  \pgfmathsetmacro\hobby@rho{%
    (2 + \hobby@alpha)/(1 + (1 - (3 - sqrt(5))/2)%
  * cos(\hobby@thetaone r) +  (3 - sqrt(5))/2 * cos(\hobby@phitwo r))}%
  \pgfmathsetmacro\hobby@sigma{%
    (2 - \hobby@alpha)/(1 + (1 - (3 - sqrt(5))/2)%
  * cos(\hobby@phitwo r) +  (3 - sqrt(5))/2 * cos(\hobby@thetaone r))}%
  \hobby@qpoints
  \pgf@xa=\pgf@x
  \pgf@ya=\pgf@y
  \pgfmathsetlength\pgf@xa{%
    \pgf@xa + \hobby@done * \hobby@rho%
  * cos((\hobby@thetaone + \hobby@omegaone) r)/3*\hobby@sf}%
  \pgfmathsetlength\pgf@ya{%
    \pgf@ya + \hobby@done * \hobby@rho%
  * sin((\hobby@thetaone + \hobby@omegaone) r)/3*\hobby@sf}%
  \hobby@qpointa
  \pgf@xb=\pgf@x
  \pgf@yb=\pgf@y
  \pgfmathsetlength\pgf@xb{%
    \pgf@xb - \hobby@done * \hobby@sigma%
  * cos((-\hobby@phitwo + \hobby@omegaone) r)/3*\hobby@sf}%
  \pgfmathsetlength\pgf@yb{%
    \pgf@yb - \hobby@done * \hobby@sigma%
  * sin((-\hobby@phitwo + \hobby@omegaone) r)/3*\hobby@sf}%
  \hobby@qpointa
  \edef\hobby@quick@path{\hobby@quick@path .. controls%
  (\the\pgf@xa,\the\pgf@ya) and (\the\pgf@xb,\the\pgf@yb) .. (\the\pgf@x,\the\pgf@y) }%
}{%
%    \end{macrocode}
% More to go, scan in the next coordinate and off we go again.
%    \begin{macrocode}
\tikz@scan@one@point\hobby@quick}}
%    \end{macrocode}
% \end{function}
%
% \iffalse
%</tikzlibrary>
% \fi
%
% \subsection{Arrays}
%
% \iffalse
%<*array>
% \fi
% 
%
% A lot of our data structures are really arrays.
% These are implemented as \LaTeX3 ``property lists''.
% For ease of use, an array is a property list with numeric entries together with entries ``base'' and ``top'' which hold the lowest and highest indices that have been set.
%
%    \begin{macrocode}
\RequirePackage{expl3}
\ExplSyntaxOn
%    \end{macrocode}
% Some auxiliary variables.
%    \begin{macrocode}
\tl_new:N \l_array_tmp_tl
\tl_new:N \l_array_show_tl
\int_new:N \l_array_base_int
\int_new:N \l_array_top_int
\int_new:N \l_array_tmp_int
%    \end{macrocode}
% The global variable \Verb+\g_array_base_int+ says what index a blank array should start with when pushed or unshifted.
%    \begin{macrocode}
\int_new:N \g_array_base_int
\int_set:Nn \g_array_base_int {0}
%    \end{macrocode}
% \begin{function}{\array_adjust_ends:Nn}
% This ensures that the ``base'' and ``top'' are big enough to include the given index.
%    \begin{macrocode}
\cs_new:Npn \array_adjust_ends:Nn #1#2 {
  \prop_get:NnNTF #1 {base} \l_tmpa_tl
  {
    \int_compare:nNnTF {\l_tmpa_tl} > {#2}
    {
      \prop_put:Nnx #1 {base} {\int_eval:n {#2}}
    }
    {}
  }
  {
    \prop_put:Nnx #1 {base} {\int_eval:n {#2}}
  }
  \prop_get:NnNTF #1 {top} \l_tmpa_tl
  {
    \int_compare:nNnTF {\l_tmpa_tl} < {#2}
    {
      \prop_put:Nnx #1 {top} {\int_eval:n {#2}}
    }
    {}
  }
  {
    \prop_put:Nnx #1 {top} {\int_eval:n {#2}}
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_put:Nnn}
% When adding a value to an array we have to adjust the ends.
%    \begin{macrocode}
\cs_new:Npn \array_put:Nnn #1#2#3 {
  \exp_args:NNx \prop_put:Nnn #1 {\int_eval:n {#2}} {#3}
  \array_adjust_ends:Nn #1{#2}
}
\cs_generate_variant:Nn \array_put:Nnn {Nnx}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_get:NnN}
%    \begin{macrocode}
\cs_new:Npn \array_get:NnN #1#2#3 {
  \exp_args:NNx \prop_get:NnN #1 {\int_eval:n {#2}} #3
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}[EXP]{\array_get:Nn}
%    \begin{macrocode}
\cs_new:Npn \array_get:Nn #1#2 {
  \exp_args:NNf \prop_get:Nn #1 { \int_eval:n {#2} }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_get:NnNTF}
%    \begin{macrocode}
\cs_new:Npn \array_get:NnNTF #1#2#3#4#5 {
  \exp_args:NNx \prop_get:NnNTF #1 {\int_eval:n {#2}} #3 {#4}{#5}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_if_empty:NTF}
%    \begin{macrocode}
\cs_new_eq:NN \array_if_empty:NTF \prop_if_empty:NTF
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_new:N}
%    \begin{macrocode}
\cs_new_eq:NN \array_new:N \prop_new:N
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_clear:N}
%    \begin{macrocode}
\cs_new_eq:NN \array_clear:N \prop_clear:N
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_map_function}
% When stepping through an array, we want to iterate in order so a simple wrapper to \Verb+\prop_map_function+ is not enough.
% This maps through every value from the base to the top so the function should be prepared to deal with a \Verb+\q_no_value+.
%    \begin{macrocode}
\cs_new:Npn \array_map_function:NN #1#2
{
  \array_if_empty:NTF #1 {} {
    \prop_get:NnNTF #1 {base} \l_array_tmp_tl {
      \int_set:Nn \l_array_base_int {\l_array_tmp_tl}
    }{
      \int_set:Nn \l_array_base_int {0}
    }
    \prop_get:NnNTF #1 {top} \l_array_tmp_tl {
      \int_set:Nn \l_array_top_int {\l_array_tmp_tl}
    }{
      \int_set:Nn \l_array_top_int {0}
    }
    \prg_stepwise_inline:nnnn {\l_array_base_int} {1} {\l_array_top_int} {
  \array_get:NnN #1 {##1} \l_array_tmp_tl
  \exp_args:Nno #2 {##1} \l_array_tmp_tl
}
} {}
}
\cs_generate_variant:Nn \array_map_function:NN {     Nc }
\cs_generate_variant:Nn \array_map_function:NN { c , cc }
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_reverse_map_function}
% This steps through the array in reverse order.
%    \begin{macrocode}
\cs_new:Npn \array_reverse_map_function:NN #1#2
{
  \array_if_empty:NTF #1 {} {
    \prop_get:NnNTF #1 {base} \l_array_tmp_tl {
      \int_set:Nn \l_array_base_int {\l_array_tmp_tl}
    }{
      \int_set:Nn \l_array_base_int {0}
    }
    \prop_get:NnNTF #1 {top} \l_array_tmp_tl {
      \int_set:Nn \l_array_top_int {\l_array_tmp_tl}
    }{
      \int_set:Nn \l_array_top_int {0}
    }
    \prg_stepwise_inline:nnnn {\l_array_top_int} {-1} {\l_array_base_int} {
  \array_get:NnN #1 {##1} \l_array_tmp_tl
  \exp_args:Nno #2 {##1} \l_array_tmp_tl
}
} {}
}
\cs_generate_variant:Nn \array_reverse_map_function:NN {     Nc }
\cs_generate_variant:Nn \array_reverse_map_function:NN { c , cc }
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_map_inline:Nn}
% Inline version of the above.
%    \begin{macrocode}
\cs_new_protected:Npn \array_map_inline:Nn #1#2
  {
    \int_gincr:N \g_prg_map_int
    \cs_gset:cpn { array_map_inline_ \int_use:N \g_prg_map_int :nn }
      ##1##2 {#2}
    \exp_args:NNc \array_map_function:NN #1
      { array_map_inline_ \int_use:N \g_prg_map_int :nn }
    \prg_break_point:n { \int_gdecr:N \g_prg_map_int }
  }
\cs_generate_variant:Nn \array_map_inline:Nn { c }
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_reverse_map_inline:Nn}
% Inline version of the above.
%    \begin{macrocode}
\cs_new_protected:Npn \array_reverse_map_inline:Nn #1#2
  {
    \int_gincr:N \g_prg_map_int
    \cs_gset:cpn { array_map_inline_ \int_use:N \g_prg_map_int :nn }
      ##1##2 {#2}
    \exp_args:NNc \array_reverse_map_function:NN #1
      { array_map_inline_ \int_use:N \g_prg_map_int :nn }
    \prg_break_point:n { \int_gdecr:N \g_prg_map_int }
  }
\cs_generate_variant:Nn \array_reverse_map_inline:Nn { c }
%    \end{macrocode}
% \end{function}
%
% For displaying arrays, we need some messages.
%    \begin{macrocode}
\msg_new:nnn { array } { show }
  {
    The~array~\token_to_str:N #1~
    \array_if_empty:NTF #1
      { is~empty }
      { contains~the~items~(without~outer~braces): }
  }
%    \end{macrocode}
%
% \begin{function}{\array_show:N}
% Mapping through an array isn't expandable so we have to set a token list to its contents first before passing it to the message handler.
%    \begin{macrocode}
\cs_new_protected:Npn \array_show:N #1
  {
    \tl_clear:N \l_array_show_tl
    \array_map_function:NN #1 \array_show_aux:nn
    \__msg_show_variable:Nnx
      #1
      { array }
      { \l_array_show_tl }
  }

\cs_new_protected:Npn \array_show_aux:nn #1#2
{
  \tl_if_eq:NNTF {#2} {\q_no_value} {}
  {
  \tl_put_right:No \l_array_show_tl {\__msg_show_item:nn {#1}{#2}}
  }
}
\cs_generate_variant:Nn \array_show:N { c }
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_push:Nn}
%    \begin{macrocode}
\cs_new_protected:Npn \array_push:Nn #1#2
{
  \prop_get:NnNTF #1 {top} \l_array_tmp_tl
  {
    \int_set:Nn \l_array_tmp_int {\l_array_tmp_tl}
    \int_incr:N \l_array_tmp_int
    \array_put:Nnn #1 {\l_array_tmp_int} {#2}
  }
  {
    \array_put:Nnn #1 {\g_array_base_int} {#2}
  }
}
\cs_generate_variant:Nn \array_push:Nn {Nx}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_unshift:Nn}
%    \begin{macrocode}
\cs_new_protected:Npn \array_unshift:Nn #1#2
{
  \prop_get:NnNTF #1 {base} \l_array_tmp_tl
  {
    \int_set:Nn \l_array_tmp_int {\l_array_tmp_tl}
    \int_decr:N \l_array_tmp_int
    \array_put:Nnn #1 {\l_array_tmp_int} {#2}
  }
  {
    \array_put:Nnn #1 {\g_array_base_int} {#2}
  }
}
\cs_generate_variant:Nn \array_unshift:Nn {Nx}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_pop:NN}
%    \begin{macrocode}
\cs_new_protected:Npn \array_pop:NN #1#2
{
  \prop_get:NnN #1 {top} \l_array_tmp_tl
  \array_get:NnN #1 {\l_array_tmp_tl} #2
  \array_del:Nn #1 {\l_array_tmp_tl}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_shift:NN}
%    \begin{macrocode}
\cs_new_protected:Npn \array_shift:NN #1#2
{
  \prop_get:NnN #1 {base} \l_array_tmp_tl
  \array_get:NnN #1 {\l_array_tmp_tl} #2
  \array_del:Nn #1 {\l_array_tmp_tl}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_top:NN}
%    \begin{macrocode}
\cs_new_protected:Npn \array_top:NN #1#2
{
  \prop_get:NnN #1 {top} \l_array_tmp_tl
  \array_get:NnN #1 {\l_array_tmp_tl} #2
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_base:NN}
%    \begin{macrocode}
\cs_new_protected:Npn \array_base:NN #1#2
{
  \prop_get:NnN #1 {base} \l_array_tmp_tl
  \array_get:NnN #1 {\l_array_tmp_tl} #2
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_top:N}
%    \begin{macrocode}
\cs_new:Npn \array_top:N #1
{
  \array_get:Nn #1 {\prop_get:Nn #1 {top}}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_base:N}
%    \begin{macrocode}
\cs_new:Npn \array_base:N #1
{
  \array_get:Nn #1 {\prop_get:Nn #1 {base}}
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_del:Nn}
%    \begin{macrocode}
\cs_new_protected:Npn \array_del:Nn #1#2
{
  \exp_args:NNx \prop_del:Nn #1 {\int_eval:n {#2}}
  \int_set:Nn \l_array_tmp_int {0}
  \array_map_inline:Nn #1 {
    \tl_if_eq:NNTF {##2} {\q_no_value} {}
    {
      \int_incr:N \l_array_tmp_int
    }
  }
  \int_show:N \l_array_tmp_int
  \int_compare:nNnTF {\l_array_tmp_int} = {0}
  {
    \prop_clear:N #1
  }
  {
  \prop_get:NnN #1 {top} \l_array_tmp_tl
  \int_compare:nNnTF {#2} = {\l_array_tmp_tl} {
    \prop_get:NnN #1 {base} \l_array_tmp_tl
    \int_set:Nn \l_array_tmp_int {\l_array_tmp_tl}
    \array_map_inline:Nn #1 {
    \tl_if_eq:NNTF {##2} {\q_no_value} {}
    {
      \int_compare:nNnTF {\l_array_tmp_int} < {##1} {
        \int_set:Nn \l_array_tmp_int {##1}
      }{}
    }
      }
    \prop_put:Nnx #1 {top} {\int_use:N \l_array_tmp_int}
  }{}
  \prop_get:NnN #1 {base} \l_array_tmp_tl
  \int_compare:nNnTF {#2} = {\l_array_tmp_tl} {
p    \prop_get:NnN #1 {top} \l_array_tmp_tl
    \int_set:Nn \l_array_tmp_int {\l_array_tmp_tl}
    \array_map_inline:Nn #1 {
    \tl_if_eq:NNTF {##2} {\q_no_value} {}
    {
      \int_compare:nNnTF {\l_array_tmp_int} > {##1} {
        \int_set:Nn \l_array_tmp_int {##1}
      }{}
    }
      }
    \prop_put:Nnx #1 {base} {\int_use:N \l_array_tmp_int}
  }{}
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}{\array_length:N}
%    \begin{macrocode}
\cs_new_protected:Npn \array_length:N #1
{
  \int_eval:n {\prop_get:Nn #1 {top} - \prop_get:Nn #1 {base}}
}
%    \end{macrocode}
% \end{function}
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
%
% \iffalse
%</array>
% \fi
% 
%\Finale
