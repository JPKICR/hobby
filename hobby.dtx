% \iffalse meta-comment
%<*internal>
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
Copyright (C) 2012 by Andrew Stacey
-------------------------------------------

This file may be distributed and/or modified under the
conditions of the LaTeX Project Public License, either version 1.3
of this license or (at
 your option) any later version.
The latest version of this license is in:

   http://www.latex-project.org/lppl.txt

and version 1.3 or later is part of all distributions of LaTeX
version 2005/12/01 or later.
\endpreamble
\generate{\file{tikzlibraryhobby.code.tex} {\from{hobby.dtx}{tikzlibrary}}}
\generate{\file{pgflibraryhobby.code.tex} {\from{hobby.dtx}{pgflibrary}}}
\generate{\file{hobby.code.tex}
{\from{hobby.dtx}{hobby}}}
%</install>
%<install>\endbatchfile
%<*internal>
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver>
\documentclass{l3doc}
\usepackage[T1]{fontenc}
\usepackage{csquotes}
\usepackage{lmodern}
\usepackage{tikz}
\usepackage{amsmath}
\usetikzlibrary{hobby,decorations.pathreplacing}
\usepackage[margin=3cm]{geometry}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\tikzset{
  shape example/.style={
    color=black!30,
    draw,
    fill=yellow!30,
    line width=.5cm,
    inner xsep=2.5cm,
    inner ysep=0.5cm}
}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{Hobby's Algorithm in TikZ/PGF}
% \author{Andrew Stacey}
% \date{2012-05-15}
% \maketitle
%
% 
% \section{Usage}
%
% The package is provided in form of a PGF library.
% It can be loaded with
% \begin{verbatim}
% \usetikzlibrary{hobby}
% \end{verbatim}
% or
% \begin{verbatim}
% \usepgflibrary{hobby}
% \end{verbatim}
%
% The TikZ library installs a \Verb+to path+ which draws a smooth curve through the given points:
%
% \begin{verbatim}
% \draw (0,0) to[curve through={(6,4) .. (4,9) .. (1,7)}] (3,5);
% \end{verbatim}
%
% There is also the facility to subvert TikZ's path processor and define curves simply using the \Verb+..+ separator between points.
% Note that this relies on something a little special in TikZ: the syntax \Verb+(0,0) .. (2,3)+ is currently detected and processed but there is no action assigned to that syntax.
% If a later version of TikZ assigns some action to that syntax, this package should make its override optional.
%
% \begin{verbatim}
% \draw (-3,0) -- (0,0) .. (6,4) .. (4,9) .. (1,7) .. (3,5) -- ++(2,0);
% \end{verbatim}
%
% The algorithm can deal with open or closed paths, it is possible to vary the ``tensions'' between the specified points of the paths, and for an open path it is possible to specify the incoming and outgoing angles either directly or via certain ``curl'' parameters.
%
% \tikzset{
%   show curve controls/.style={
%    decoration={
%      show path construction,
%      curveto code={
%      \draw [blue, dashed]
%          (\tikzinputsegmentfirst)    -- (\tikzinputsegmentsupporta)
%          node [at end, draw, solid, red, inner sep=2pt]{};
%        \draw [blue, dashed]
%          (\tikzinputsegmentsupportb) -- (\tikzinputsegmentlast)
%          node [at start, draw, solid, red, inner sep=2pt]{};
%      }
%    },decorate
%  },
% }
%
% \begin{tikzpicture}
% \draw[scale=.1,postaction=show curve controls,line width=1mm,red] (0,0)
% .. controls (26.76463,-1.84543) and (51.4094,14.58441) .. (60,40)
% .. controls (67.09875,61.00188) and (59.76253,84.57518) .. (40,90)
% .. controls (25.35715,94.01947) and (10.48064,84.5022) .. (10,70)
% .. controls (9.62895,58.80421) and (18.80421,49.62895) .. (30,50);
% 
% \fill[green] (0,0) circle[radius=2pt]
%  (6,4) circle[radius=2pt]
%  (4,9) circle[radius=2pt]
%  (1,7) circle[radius=2pt]
%  (3,5) circle[radius=2pt];
% \draw[postaction=show curve controls,thick] (0,0) to[curve through={(6,4) .. (4,9) .. (1,7)}] (3,5);
% 
% \end{tikzpicture}
% 
% \begin{tikzpicture}
% \draw[scale=.1,postaction=show curve controls,line width=1mm,red] (0,0)
% .. controls (26.76463,-1.84543) and (51.4094,14.58441) .. (60,40)
% .. controls (67.09875,61.00188) and (59.76253,84.57518) .. (40,90)
% .. controls (25.35715,94.01947) and (10.48064,84.5022) .. (10,70)
% .. controls (9.62895,58.80421) and (18.80421,49.62895) .. (30,50);
% 
% \fill[green] (0,0) circle[radius=2pt]
%  (6,4) circle[radius=2pt]
%  (4,9) circle[radius=2pt]
%  (1,7) circle[radius=2pt]
%  (3,5) circle[radius=2pt];
% \draw (-3,0) -- (0,0) .. (6,4) .. (4,9) .. (1,7) .. (3,5) -- ++(2,0);
% \end{tikzpicture}
% 
% \begin{tikzpicture}
% \draw[scale=.1,postaction=show curve controls,line width=1mm,red] (0,0)
% .. controls (5.18756,-26.8353) and (60.36073,-18.40036) .. (60,40)
% .. controls (59.87714,59.889) and (57.33896,81.64203) .. (40,90)
% .. controls (22.39987,98.48387) and (4.72404,84.46368) .. (10,70)
% .. controls (13.38637,60.7165) and (26.35591,59.1351) .. (30,50)
% .. controls (39.19409,26.95198) and (-4.10555,21.23804) .. (0,0); % 
% \fill[green] (0,0) circle[radius=2pt]
%  (6,4) circle[radius=2pt]
%  (4,9) circle[radius=2pt]
%  (1,7) circle[radius=2pt]
%  (3,5) circle[radius=2pt];
% \draw[postaction=show curve controls,thick] (0,0) to[closed,curve through={(6,4) .. (4,9) .. (1,7)}] (3,5);
% 
% \end{tikzpicture}
% 
% \section{Implementing Hobby's Algorithm}
% 
% We start with a list of \(n+1\) points, \(z_0, \dotsc, z_n\).
% The base code assumes that these are already stored in two property lists: the \(x\)--coordinates in \Verb+\l_hobby_pointsx_prop+ and the \(y\)--coordinates in \Verb+\l_hobby_pointsy_prop+.
% As our arrays are \(0\)--indexed, the actual number of points is one more than this.
% For a closed curve, we have \(z_n = z_0\)\footnote{Note that there is a difference between a closed curve and an open curve whose endpoints happen to overlap}.
% For closed curves it will be convenient to add an additional point at \(z_1\): thus \(z_{n+1} = z_1\).
% This makes \(z_n\) an internal point and makes the algorithms for closed paths and open paths agree longer than they would otherwise.
% The number of apparent points is stored as \Verb+\l_hobby_npoints_int+.
% Thus for an open path, \Verb+\l_hobby_npoints_int+ is \(n\), whilst for a closed path, it is \(n+1\)\footnote{In fact, we allow for the case where the user specifies a closed path but with \(z_n \ne z_0\).
% In that case, we assume that the user meant to repeat \(z_0\).
% This adds another point to the list.}.
% Following Hobby, let us write \(n'\) for \(n\) if the path is open and \(n+1\) if closed.
%
% From this we compute the distances and angles between successive points, storing these again as property lists.
% These are \Verb+\l_hobby_distances_prop+ and \Verb+\l_hobby_angles_prop+.
% The term indexed by \(k\) is the distance (or angle) of the line between the \(k\)th point and the \(k+1\)th point.
% For the internal nodes\footnote{Hobby calls the specified points \emph{knots}}, we store the difference in the angles in \Verb+\l_hobby_psi_prop+.
% The \(k\)th value on this is the angle subtended at the \(k\)th node.
% This is thus indexed from \(1\) to \(n'-1\).
% 
% The bulk of the work consists in setting up a linear system to compute the angles of the control points.
% At a node, say \(z_i\), we have various pieces of information:
%
% \begin{enumerate}
% \item The angle of the incoming curve, \(\phi_i\), relative to the straight line from \(z_{i-1}\) to \(z_i\)
% \item The angle of the outgoing curve, \(\theta_i\), relative to the straight line from \(z_i\) to \(z_{i+1}\)
% \item The tension of the incoming curve, \(\overline{\tau}_i\)
% \item The tension of the outgoing curve, \(\tau_i\)
% \item The speed of the incoming curve, \(\sigma_i\)
% \item The speed of the outgoing curve, \(\rho_i\)
% \end{enumerate}
%
% The tensions are known at the start.
% The speeds are computed from the angles.
% Thus the key thing to compute is the angles.
% This is done by imposing a ``mock curvature'' condition.%
% The formula for the mock curvature is:
%^^A
% \[
%   \hat{k}(\theta,\phi,\tau,\overline{\tau}) = \tau^2 \left( \frac{2(\theta + \phi)}{\overline{\tau}} - 6\theta\right)
% \]
%^^A
% and the condition that the mock curvatures have to satisfy is that at each \emph{internal} node, the curvatures must match:
% %
% \[
%   \hat{k}(\phi_i,\theta_{i-1},\overline{\tau}_i,\tau_{i-1})/d_{i-1} = \hat{k}(\theta_i,\phi_{i+1},\tau_i,\overline{\tau}_{i+1})/d_i.
% \]
%^^A
% Substituting in yields:
%^^A
% \[
%   \frac{\overline{\tau}_i^2}{d_{i-1}} \left( \frac{2(\phi_i + \theta_{i-1})}{\tau_{i-1}} - 6\phi_i\right) = \frac{\tau_i^2}{d_i} \left( \frac{2(\theta_i + \phi_{i+1})}{\overline{\tau}_{i+1}} - 6\theta_i \right).
% \]
%^^A
% Let us rearrange that to the following:
%^^A
% \begin{align*}
%   d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 &\theta_{i-1} \\
%^^A
% +
% d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (1 - 3 \tau_{i-1}) &\phi_i \\
%^^A
% -
%  d_{i-1} \tau_{i-1} \tau_i^2 (1 - 3 \overline{\tau}_{i+1}) &\theta_i \\
%^^A
% -
%  d_{i-1} \tau_{i-1} \tau_i^2 &\phi_{i+1} \\
%^^A
% =
% 0
% \end{align*}
%^^A
% For both open and closed paths this holds for \(i=1\) to \(i=n' - 1\).
% 
% We also have the condition that \(\theta_i + \phi_i = -\psi_i\) where \(\psi_i\) is the angle subtended at a node by the lines to the adjacent nodes.
% This holds for the internal nodes\footnote{Recall that by dint of repetition, all nodes are effectively internal for a closed path}.
% Therefore for \(i=1\) to \(n'-1\) the above simplifies to the following:
% %
% \begin{align*}
%   d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 &\theta_{i-1} \\
% +
% (d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1)
% +
%  d_{i-1} \tau_{i-1} \tau_i^2 (3 \overline{\tau}_{i+1} - 1)) &\theta_i \\
% +
%  d_{i-1} \tau_{i-1} \tau_i^2 & \theta_{i+1} \\
% =
% - d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1) &\psi_i \\
% - d_{i-1} \tau_{i-1} \tau_i^2& \psi_{i+1}
% \end{align*}
% 
% For an open path we have two more equations.
% One involves \(\theta_0\).
% The other is the above for \(i = n'-1 = n-1\) with additional information regarding \(\psi_n\).
% It may be that one or either of \(\theta_0\) or \(\psi_n\) is specified in advance.
% In that case, the first equation is simply setting \(\theta_0\) to that value and the last equation involves substituting the value for \(\psi_n\) into the above.
% If not, they are given by formulae involving ``curl'' parameters \(\chi_0\) and \(\chi_n\) and result in the equations:
% %
% \begin{align*}
% \theta_0 &= \frac{\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)}{\tau_0^3(3 \overline{\tau}_1 - 1) + \chi_0 \overline{\tau}_1^3} \phi_1 \\
% \phi_n &= \frac{\overline{\tau}_n^3 + \chi_n \tau_{n-1}^3(3 \overline{\tau}_n - 1)}{\overline{\tau}_n^3(3 \tau_{n-1} - 1) + \chi_n \tau_{n-1}^3} \theta_{n-1}
% \end{align*}
%^^A
% Using \(\phi_1 = - \psi_1 - \theta_1\), the first rearranges to:
%^^A
% \[
% (\tau_0^3(3 \overline{\tau}_1 - 1) + \chi_0 \overline{\tau}_1^3) \theta_0 + (\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)) \theta_1 = - (\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)) \psi_1.
% \]
%^^A
% The second should be substituted in to the general equation with \(i = n-1\).
% This yields:
%^^A  
% \begin{align*}
%   d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 &\theta_{n-2} \\
% +
% (d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1)
% +
%  d_{n-2} \tau_{n-2} \tau_{n-1}^2 (3 \overline{\tau}_{n} - 1) \\
% - d_{n-2} \tau_{n-2} \tau_{n-1}^2  \frac{\overline{\tau}_n^3 + \chi_n \tau_{n-1}^3(3 \overline{\tau}_n - 1)}{\overline{\tau}_n^3(3 \tau_{n-1} - 1) + \chi_n \tau_{n-1}^3}) & \theta_{n-1} \\
% =
% - d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) &\psi_{n-1}
% \end{align*}
%^^A
% This gives \(n'\) equations in \(n'\) unknowns (\(\theta_0\) to \(\theta_{n-1}\)).
% The coefficient matrix is tridiagonal.
% It is more natural to index the entries from \(0\).
% Let us write \(A_i\) for the subdiagonal, \(B_i\) for the main diagonal, and \(C_i\) for the superdiagonal.
% Let us write \(D_i\) for the target vector.
% Then for an open path we have the following formulae:
%^^A
% \begin{align*}
% A_i &= d_i \overline{\tau}_{i+1} \overline{\tau}^2_i \\
% B_0 &= \begin{cases}
% 1 & \text{if}\; \theta_0\; \text{given} \\
% \tau_0^3(3 \overline{\tau}_1 - 1) + \chi_0 \overline{\tau}^3_1 & \text{otherwise}
% \end{cases} \\
% B_i &= d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} -1) + d_{i-1} \tau_{i-1} \tau_i^2(3 \overline{\tau}_{i+1} - 1) \\
% B_{n-1} &= \begin{cases} d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) + d_{n-2} \tau_{n-2} \tau_{n-1}^2(3 \overline{\tau}_{n} - 1) & \text{if}\; \phi_n\; \text{given} \\
%  d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) + d_{n-2} \tau_{n-2} \tau_{n-1}^2(3 \overline{\tau}_{n} - 1)
% \\
% - d_{n-2} \tau_{n-2} \tau_{n-1}^2  \frac{\overline{\tau}_n^3 + \chi_n \tau_{n-1}^3(3 \overline{\tau}_n - 1)}{\overline{\tau}_n^3(3 \tau_{n-1} - 1) + \chi_n \tau_{n-1}^3}) & \text{otherwise}
% \end{cases} \\
% C_0 &= \begin{cases}
% 0 & \text{if}\; \theta_0\; \text{given} \\
% \tau_0^3 + \chi_0 \overline{\tau}_1^3(3\tau_0 - 1) & \text{otherwise}
% \end{cases} \\
% C_i &= d_{i-1} \tau_{i-1} \tau_i^2 \\
% D_0 &= \begin{cases}
% \overline{\theta}_0 & \text{if}\; \theta_0\; \text{given} \\
%  - (\tau_0^3 + \chi_0 \overline{\tau}_1^3(3 \tau_0 - 1)) \psi_1 & \text{otherwise}
% \end{cases} \\
% D_i &= - d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1) \psi_i
% - d_{i-1} \tau_{i-1} \tau_i^2 \psi_{i+1} \\
% D_{n-1} &= \begin{cases}
% - d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) \psi_{n-1} - d_{n-2} \tau_{n-2} \tau_{n-1}^2 \overline{\phi}_n & \text{if}\; \phi_n\; \text{given} \\
% - d_{n-1} \overline{\tau}_{n} \overline{\tau}_{n-1}^2 (3 \tau_{n-2} - 1) \psi_{n-1} & \text{otherwise}
% \end{cases}
% \end{align*}
%
% For a closed path, we have \(n\) equations in \(n+2\) unknowns (\(\theta_0\) to \(\theta_{n+1}\)).
% However, we have not included all the information.
% Since we have repeated points, we need to identify \(\theta_0\) with \(\theta_n\) and \(\theta_1\) with \(\theta_{n+1}\).
% To get a system with \(n'\) equations in \(n'\) unknowns, we add the equation \(\theta_0 - \theta_n = 0\) and substitute in \(\theta_{n+1} = \theta_1\).
% The resulting matrix is not quite tridiagonal but has extra entries on the off-corners.
% However, it can be written in the form \(M + u v^\top\) with \(M\) tridiagonal.
% There is some freedom in choosing \(u\) and \(v\).
% For simplest computation, we take \(u = e_0 + e_{n'-1}\).
% This means that \(v = d_{n'-2} \tau_{n'-2} \tau_{n'-1}^2 e_1 - e_{n'-1}\).
% With the same notation as above, the matrix \(M\) is given by the following formulae:
%^^A
% \begin{align*}
% A_i &= d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 \\
%^^A
% B_0 &= 1 \\
%^^A
% B_i &= d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} -1) + d_{i-1} \tau_{i-1} \tau_i^2(3 \overline{\tau}_{i+1} - 1) \\
%^^A
% B_{n'-1} &= d_{n'-1} \overline{\tau}_{n'} \overline{\tau}_{n'-1}^2 (3 \tau_{n'-2} -1) + d_{n'-2} \tau_{n'-2} \tau_{n'-1}^2(3 \overline{\tau}_{n'} - 1) + 1\\
%^^A
% C_0 &= - d_{n'-2} \tau_{n'-2} \tau_{n'-1}^2 \\
%^^A
% C_i &= d_{i-1} \tau_{i-1} \tau_i^2 \\
%^^A
% D_0 &= 0 \\
%^^A
% D_i &= - d_i \overline{\tau}_{i+1} \overline{\tau}_i^2 (3 \tau_{i-1} - 1) \psi_i
% - d_{i-1} \tau_{i-1} \tau_i^2 \psi_{i+1} \\
%^^A
% D_{n'-1} &= - d_{n'-1} \overline{\tau}_{n'} \overline{\tau}_{n'-1}^2 (3 \tau_{n'-2} - 1) \psi_{n'-1}
% - d_{n'-2} \tau_{n'-2} \tau_{n'-1}^2 \psi_1
% \end{align*}
%
% The next step in the implementation is to compute these coefficients and store them in appropriate property lists.
% Having done that, we need to solve the resulting tridiagonal system.
% This is done by looping through the arrays doing the following substitutions (starting at \(i = 1\)):
% %
% \begin{align*}
% B_i' &= B_{i-1}' B_i - A_i C_{i-1}' \\
% C_i' &= B_{i-1}' C_i \\
% D_i' &= B_{i-1}' D_i - A_i D_{i-1}'
% \end{align*}
%^^A
% followed by back-substitution:
%^^A
% \begin{align*}
% \theta_{n-1} &= D_{n-1}'/B_{n-1}' \\
% \theta_i &= (D_i' - C_i' \theta_{i+1})/B_i'
% \end{align*}
%^^A
% For a closed path, we run this both with the vector \(D\) and the vector \(u = e_0 + e_{n'-1}\).
% Then to get the real answer, we use the Sherman--{}Morrison formula:
%^^A
% \[
% (M + u v^\top)^{-1} D = M^{-1} D - \frac{M^{-1} u v^\top M^{-1} D}{1 + v^\top M^{-1} u}.
% \]
%^^A
% 
% This leaves us with the values for \(\theta_i\).
% We now substitute these into Hobby's formulae for the lengths:
% %
% \begin{align*}
% \rho_i &= \frac{2 + \alpha_i}{1 + (1 - c) \cos \theta_i + c \cos \phi_{i+1}} \\
% \sigma_{i+1} &= \frac{2 - \alpha_i}{1 + (1 - c) \cos \phi_{i+1} + c \cos \theta_i} \\
% \alpha_i &= a (\sin \theta_i - b \sin \phi_{i+1})(\sin \phi_{i+1} - b \sin \theta_i)(\cos \theta_i - \cos \phi_{i+1})
% \end{align*}
% %
% where \(a = \sqrt{2}\), \(b = 1/16\), and \(c = (3 - \sqrt{5})/2\).
% 
% Now \(\theta_i\) is the angle relative to the line from \(z_i\) to \(z_{i+1}\), so to get the true angle we need to add back that angle.
% Fortunately, we stored those angles at the start.
% So the control points are:
% %
% \begin{gather*}
%   (\rho_i \cos (\theta_i + \omega_i), \rho_i \sin (\theta_i + \omega_i)) + z_i \\
% (-\sigma_i \cos(\theta_i + \omega_i), -\sigma_i \sin(\theta_i + \omega_i)) + z_{i+1}
% \end{gather*}
% 
% 
% \begin{tikzpicture}
% \fill[green] (0,0) circle[radius=2pt]
%  (6,4) circle[radius=2pt]
%  (4,9) circle[radius=2pt]
%  (1,7) circle[radius=2pt]
%  (3,5) circle[radius=2pt];
% \draw[postaction=show curve controls,thick] (0,0) to[curve through={(6,4) .. (4,9) .. (1,7)}] (3,5);
% 
% \draw[scale=.1,postaction=show curve controls,thick,blue] (0,0)
% .. controls (26.76463,-1.84543) and (51.4094,14.58441) .. (60,40)
% .. controls (67.09875,61.00188) and (59.76253,84.57518) .. (40,90)
% .. controls (25.35715,94.01947) and (10.48064,84.5022) .. (10,70)
% .. controls (9.62895,58.80421) and (18.80421,49.62895) .. (30,50);
% 
% \end{tikzpicture}
% 
%
% \StopEventually{\PrintChanges}
% \section{Implementation}
%
% \subsection{Main Code}
%
% \iffalse
%<*hobby>
% \fi
%
% We use \LaTeX3 syntax so need to load the requisite packages
%    \begin{macrocode}
\RequirePackage{expl3}
\ExplSyntaxOn
%    \end{macrocode}
% \subsubsection{Initialisation}
%
% We declare all our variables.
%
% The function for computing the lengths of the control points depends on three parameters.
% These are set to \(a = \sqrt{2}\), \(b = 1/16\), and \(c = \frac{3 - \sqrt{5}}{2}\).
%    \begin{macrocode}
\fp_new:N \g_hobby_parama_fp
\fp_new:N \g_hobby_paramb_fp
\fp_new:N \g_hobby_paramc_fp

\fp_set:Nn \g_hobby_parama_fp {2}
\fp_pow:Nn \g_hobby_parama_fp {.5}

\fp_set:Nn \g_hobby_paramb_fp {1}
\fp_div:Nn \g_hobby_paramb_fp {16}

\fp_set:Nn \g_hobby_paramc_fp {5}
\fp_pow:Nn \g_hobby_paramc_fp {.5}
\fp_neg:N \g_hobby_paramc_fp
\fp_add:Nn \g_hobby_paramc_fp {3}
\fp_div:Nn \g_hobby_paramc_fp {2}
%    \end{macrocode}
%
% Now we define our objects for use in generating the path.
%
% \begin{macro}{\l_hobby_closed_bool}
% \Verb+\l_hobby_closed_bool+ is \Verb+true+ if the path is closed.
%    \begin{macrocode}
\bool_new:N \l_hobby_closed_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_points_prop}
% \Verb+\l_hobby_points_prop+ is a property list holding the specified points on the path.
% In the \LaTeX3 code, a ``point'' is a token list of the form \Verb+x = <number>, y = <number>+.
% This gives us the greatest flexibility in passing points back and forth between the \LaTeX3 code and any calling code.
% The property list is indexed by integers beginning with \(0\).
% In the documentation, we will use the notation \(z_k\) to refer to the \(k\)th point.
%    \begin{macrocode}
\prop_new:N \l_hobby_points_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_pointsx_prop}
% \Verb+\l_hobby_pointsx_prop+ is a property list holding the \(x\)--{}coordinates of the specified points.
%    \begin{macrocode}
\prop_new:N \l_hobby_pointsx_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_pointsy_prop}
% \Verb+\l_hobby_pointsy_prop+ is a property list holding the \(y\)--{}coordinates of the specified points.
%    \begin{macrocode}
\prop_new:N \l_hobby_pointsy_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_angles_prop}
% \Verb+\l_hobby_angles_prop+ is a property list holding the angles of the lines between the points.
% Specifically, the angle indexed by \(k\) is the angle in radians of the line from \(z_k\) to \(z_{k+1}\).
%    \begin{macrocode}
\prop_new:N \l_hobby_angles_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_distances_prop}
% \Verb+\l_hobby_distances_prop+ is a property list holding the distances between the points.
% Specifically, the distance indexed by \(k\), which we will write as \(d_k\), is the length of the line from \(z_k\) to \(z_{k+1}\).
%    \begin{macrocode}
\prop_new:N \l_hobby_distances_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tensionout_prop}
% \Verb+\l_hobby_tensionout_prop+ is a property list holding the tension for the path as it leaves each point.
% This is a parameter that controls how much the curve ``flexes'' as it leaves the point.
% In the following, this will be written \(\tau_k\).
%    \begin{macrocode}
\prop_new:N \l_hobby_tensionout_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tensionin_prop}
% \Verb+\l_hobby_tensionin_prop+ is a property list holding the tension for the path as it arrives at each point.
% This is a parameter that controls how much the curve ``flexes'' as it gets to the point.
% In the following, this will be written \(\overline{\tau}_k\).
%    \begin{macrocode}
\prop_new:N \l_hobby_tensionin_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tria_prop}
% \Verb+\l_hobby_tria_prop+ is a property list holding the subdiagonal of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(A_i\).
% The first index is \(1\).
%    \begin{macrocode}
\prop_new:N \l_hobby_tria_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_trib_prop}
% \Verb+\l_hobby_trib_prop+ is a property list holding the diagonal of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(B_i\).
% The first index is \(0\).
%    \begin{macrocode}
\prop_new:N \l_hobby_trib_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tric_prop}
% \Verb+\l_hobby_tric_prop+ is a property list holding the superdiagonal of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(C_i\).
% The first index is \(0\).
%    \begin{macrocode}
\prop_new:N \l_hobby_tric_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_trid_prop}
% \Verb+\l_hobby_trid_prop+ is a property list holding the target vector of the linear system that has to be solved to find the angles of the control points.
% In the following, this will be denoted by \(D_i\).
% The first index is \(1\).
%    \begin{macrocode}
\prop_new:N \l_hobby_trid_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_triu_prop}
% \Verb+\l_hobby_triu_prop+ is a property list holding the perturbation of the linear system for closed paths.
% The coefficient matrix for a \emph{open} path is tridiagonal and that means that Gaussian elimination runs faster than expected (\(O(n)\) instead of \(O(n^3)\)).
% The matrix for a closed path is not tridiagonal but is not far off.
% It can be solved by perturbing it to a tridiagonal matrix and then modifying the result.
% This property list represents a utility vector in that perturbation. 
% In the following, the vector will be denoted by \(u\).
% The first index is \(1\).
%    \begin{macrocode}
\prop_new:N \l_hobby_triu_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_psi_prop}
% \Verb+\l_hobby_psi_prop+ is a property list holding the difference of the angles of the lines entering and exiting a point.
% That is, \(\psi_k\) is the angle between the lines joining \(z_k\) to \(z_{k-1}\) and \(z_{k+1}\).
% The first index is \(1\).
%    \begin{macrocode}
\prop_new:N \l_hobby_psi_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_theta_prop}
% \Verb+\l_hobby_theta_prop+ is a property list holding the angles of the outgoing control points for the generated path.
% These are measured relative to the line joining the point to the next point on the path.
% The first index is \(0\).
%    \begin{macrocode}
\prop_new:N \l_hobby_theta_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_phi_prop}
% \Verb+\l_hobby_phi_prop+ is a property list holding the angles of the incoming control points for the generated path.
% These are measured relative to the line joining the point to the previous point on the path.
% The first index is \(1\).
%    \begin{macrocode}
\prop_new:N \l_hobby_phi_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_sigma_prop}
% \Verb+\l_hobby_sigma_prop+ is a property list holding the lengths of the outgoing control points for the generated path.
% The units are such that the length of the line to the next specified point is one unit.
%    \begin{macrocode}
\prop_new:N \l_hobby_sigma_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_rho_prop}
% \Verb+\l_hobby_rho_prop+ is a property list holding the lengths of the incoming control points for the generated path.
% The units are such that the length of the line to the previous specified point is one unit.
%    \begin{macrocode}
\prop_new:N \l_hobby_rho_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_controla_prop}
% \Verb+\l_hobby_controla_prop+ is a property list holding the coordinates of the first control points on the curves.
% The format is the same as for \Verb+\l_hobby_points_prop+.
%    \begin{macrocode}
\prop_new:N \l_hobby_controla_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_controlb_prop}
% \Verb+\l_hobby_controlb_prop+ is a property list holding the coordinates of the second control points on the curves.
% The format is the same as for \Verb+\l_hobby_points_prop+.
%    \begin{macrocode}
\prop_new:N \l_hobby_controlb_prop
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_triv_fp}
% \Verb+\l_hobby_triv_fp+ is a number which is used when doing the perturbation of the solution of the linear system for a closed curve.
% There is actually a vector, \(v\), that this corresponds to but that vector only has one component that needs computation.
%    \begin{macrocode}
\fp_new:N \l_hobby_triv_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempa_fp}
% \Verb+\l_hobby_tempa_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempa_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempb_fp}
% \Verb+\l_hobby_tempb_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempb_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempc_fp}
% \Verb+\l_hobby_tempc_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempc_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_tempd_fp}
% \Verb+\l_hobby_tempd_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_tempd_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_temps_fp}
% \Verb+\l_hobby_temps_fp+ is a temporary variable of type \Verb+fp+.
%    \begin{macrocode}
\fp_new:N \l_hobby_temps_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_incurl_fp}
% \Verb+\l_hobby_incurl_fp+ is the ``curl'' at the end of an open path.
% This is used if the angle at the end is not specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_incurl_fp
\fp_set:Nn \l_hobby_incurl_fp {1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_outcurl_fp}
% \Verb+\l_hobby_outcurl_fp+ is the ``curl'' at the start of an open path.
% This is used if the angle at the start is not specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_outcurl_fp
\fp_set:Nn \l_hobby_outcurl_fp {1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_inang_fp}
% \Verb+\l_hobby_inang_fp+ is the angle at the end of an open path.
% If this is not specified, it will be computed automatically.
% It is set to \Verb+\c_undefined_fp+ to allow easy detection of when it has been specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_inang_fp
\fp_set_eq:NN \l_hobby_inang_fp \c_undefined_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_outang_fp}
% \Verb+\l_hobby_outang_fp+ is the angle at the start of an open path.
% If this is not specified, it will be computed automatically.
% It is set to \Verb+\c_undefined_fp+ to allow easy detection of when it has been specified.
%    \begin{macrocode}
\fp_new:N \l_hobby_outang_fp
\fp_set_eq:NN \l_hobby_outang_fp \c_undefined_fp
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\l_hobby_npoints_int}
% \Verb+\l_hobby_npoints_int+ is one less than the number of points on the curve.
% As our list of points starts at \(0\), this is the index of the last point.
% In the algorithm for a closed curve, some points are repeated whereupon this is incremented so that it is always the index of the last point. 
%    \begin{macrocode}
\int_new:N \l_hobby_npoints_int
%    \end{macrocode}
% \end{macro}
%
% A ``point'' is a key-value list setting the x-value, the y-value, and the tensions at that point.
% Using keys makes it easier to pass points from the algorithm code to the calling code and vice versa without either knowing too much about the other.
%    \begin{macrocode}
\keys_define:nn {hobby / read in all} {
  x .fp_set:N = \l_hobby_tempa_fp,
  y .fp_set:N = \l_hobby_tempb_fp,
  tension~out .fp_set:N = \l_hobby_tempc_fp,
  tension~in .fp_set:N = \l_hobby_tempd_fp,
  tension~out .default:n = 1,
  tension~in .default:n = 1,
}
%    \end{macrocode}
% There are certain other parameters than can be set for a give curve.
%    \begin{macrocode}
\keys_define:nn { hobby / read in params} {
  in~angle .fp_set:N = \l_hobby_inang_fp,
  out~angle .fp_set:N = \l_hobby_outang_fp,
  in~curl .fp_set:N = \l_hobby_incurl_fp,
  out~curl .fp_set:N = \l_hobby_outcurl_fp,
  closed .bool_set:N = \l_hobby_closed_bool,
  closed .default:n = true,
}
%    \end{macrocode}
% \begin{macro}{\hobby_distangle:n}
% Computes the distance and angle between successive points.
% The argument given is the index of the current point.
% Assumptions: the points are in \Verb+\l_hobby_pointsx_prop+ and \Verb+\l_hobby_pointsy_prop+ and the index of the last point is \Verb+\l_hobby_npoints_int+.
%    \begin{macrocode}
\cs_set:Nn \hobby_distangle:n {
    \exp_args:NNx \prop_get:NnN \l_hobby_pointsx_prop {\int_eval:n {#1 + 1}} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \exp_args:NNx \prop_get:NnN \l_hobby_pointsy_prop {\int_eval:n {#1 + 1}} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

    \prop_get:NnN \l_hobby_pointsx_prop {#1} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {#1} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

    \fp_atantwo:NNN \l_hobby_tempc_fp \l_hobby_tempb_fp \l_hobby_tempa_fp
    \fp_veclen:NVV \l_hobby_tempd_fp \l_hobby_tempa_fp \l_hobby_tempb_fp

    \prop_put:Nnx \l_hobby_angles_prop {#1} {\fp_to_tl:N \l_hobby_tempc_fp}
    \prop_put:Nnx \l_hobby_distances_prop {#1} {\fp_to_tl:N \l_hobby_tempd_fp}
  }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\fp_atantwo:NNN}
% Computes the angle of the point specified by the latter two arguments, storing the answer in the first.
%    \begin{macrocode}
\cs_new:Nn \fp_atantwo:NNN {
  \pgfmathparse{rad(atan2(\fp_use:N #3,\fp_use:N #2))}
  \exp_args:NNo \fp_set:Nn #1 {\pgfmathresult}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\group_after_set:NNn}
% Useful for defining auxiliary macros that set variables according to some calculation.
% From Will Robertson on TeX-SX, \url{http://tex.stackexchange.com/a/56319/86}.
%    \begin{macrocode}
\cs_if_free:NT \group_insert_after:N
  {
    \cs_set_eq:NN \group_insert_after:N \group_execute_after:N
  }

\cs_generate_variant:Nn \tl_if_empty:nT {v}
\cs_generate_variant:Nn \tl_show:N {v}
\cs_new:Nn \group_after_set:NNn
{
  #1 #2 {#3}

  \cs_if_exist:cF { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    {
      \tl_new:c { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    }

  \tl_if_empty:vT { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    {
      \group_insert_after:c
        { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }

      \tl_gset:cx { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
        {
          \tl_gclear:c { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
        }
    }

  \tl_gput_right:cx
    { g_aftergroup_ \int_use:N \etex_currentgrouplevel:D _tl }
    {
      \exp_not:n { #1 #2 } { \exp_not:V #2 }
    }
}

\cs_generate_variant:Nn \group_insert_after:N {c}
\cs_generate_variant:Nn \group_after_set:NNn {NNV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\fp_veclen:NNN}
% Computes the length of the vector specified by the latter two arguments, storing the answer in the first.
% Needs temporary variables.
%    \begin{macrocode}
\fp_new:N \l_hobby_veclena_fp
\fp_new:N \l_hobby_veclenb_fp
\cs_new:Nn \fp_veclen:Nnn {
  \group_begin:
  \fp_set:Nn \l_hobby_tempa_fp {#2}
  \fp_set:Nn \l_hobby_tempb_fp {#3}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_tempa_fp}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_hobby_tempb_fp}
  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}
  \fp_pow:Nn \l_hobby_tempa_fp {.5}
  \tl_set:Nx \l_tmpa_tl {\fp_use:N \l_hobby_tempa_fp}
  \group_after_set:NNV \fp_set:Nn #1 \l_tmpa_tl
  \group_end:
}
\cs_generate_variant:Nn \fp_veclen:Nnn {NVV}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobby_genpath:}
% This is the curve generation function.
% We assume at the start that we have a property list containing all the points that the curve must go through, and the various curve parameters have been initialised.
% So these must be set up by a wrapper function which then calls this one.
% The list of required information is:
% \begin{enumerate}
% \item \Verb+\l_hobby_pointsx_prop+
% \item \Verb+\l_hobby_pointsy_prop+
% \item \Verb+\l_hobby_npoints_int+
% \item \Verb+\l_hobby_tensionout_prop+
% \item \Verb+\l_hobby_tensionin_prop+
% \item \Verb+\l_hobby_incurl_fp+
% \item \Verb+\l_hobby_outcurl_fp+
% \item \Verb+\l_hobby_inang_fp+
% \item \Verb+\l_hobby_outang_fp+
% \item \Verb+\l_hobby_closed_bool+
% \end{enumerate}
%
%    \begin{macrocode}
\cs_new:Nn \hobby_genpath:
{
%    \end{macrocode}
% For much of the time, we can pretend that a closed path is the same as an open path.
% To do this, we need to make the end node an internal node by repeating the \(z_1\) node as the \(z_{n+1}\)th node.
% We also check that the last (\(z_n\)) and first (\(z_0\)) nodes are the same, otherwise we repeat the \(z_0\) node as well.
%    \begin{macrocode}
\bool_if:NTF \l_hobby_closed_bool {
  \prop_get:NnN \l_hobby_pointsx_prop {0} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \exp_args:NNo \prop_get:NnN \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_sub:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_compare:nNnTF {\l_hobby_tempa_fp} = {\c_zero_fp}
  {
    \prop_get:NnN \l_hobby_pointsy_prop {0} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \exp_args:NNo \prop_get:NnN \l_hobby_pointsy_prop {\int_use:N       \l_hobby_npoints_int} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \fp_compare:nNnTF {\l_hobby_tempa_fp} = {\c_zero_fp}
  {}
  {
    \int_incr:N \l_hobby_npoints_int
    \prop_get:NnN \l_hobby_points_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsx_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionin_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
  }
  }
  {
    \int_incr:N \l_hobby_npoints_int
    \prop_get:NnN \l_hobby_points_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsx_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionin_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
  }
    \int_incr:N \l_hobby_npoints_int
    \prop_get:NnN \l_hobby_points_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsx_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
   \prop_get:NnN \l_hobby_tensionout_prop {1} \l_tmpa_tl
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int} {\tl_use:N \l_tmpa_tl}
}{}
%    \end{macrocode}
% 
% Our first step is to go through the list of points and compute the distances and angles between successive points.
% Thus \(d_i\) is the distance from \(z_i\) to \(z_{i+1}\) and the angle is the angle of the line from \(z_i\) to \(z_{i+1}\).

%    \begin{macrocode}
\prg_stepwise_function:nnnN {0} {1} {\l_hobby_npoints_int - 1} \hobby_distangle:n
%    \end{macrocode}
%
% For the majority of the code, we're only really interested in the differences of the angles.
% So for each internal point we compute the differences in the angles.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \exp_args:NNx \prop_get:NnN \l_hobby_angles_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\tl_use:N \l_tmpa_tl}
    \prop_get:NnN \l_hobby_angles_prop {##1} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempa_fp {\tl_use:N \l_tmpa_tl}
    \fp_compare:nNnTF {\l_hobby_tempa_fp} > { \c_pi_fp }
    {
      \fp_sub:Nn \l_hobby_tempa_fp {\c_pi_fp}
      \fp_sub:Nn \l_hobby_tempa_fp {\c_pi_fp}
    }
    {}
    \fp_set_eq:NN \l_hobby_tempb_fp \l_hobby_tempa_fp
    \fp_neg:N \l_hobby_tempb_fp
    \fp_compare:nNnTF {\l_hobby_tempb_fp} > {\c_pi_fp }
    {
      \fp_add:Nn \l_hobby_tempa_fp {\c_pi_fp}
      \fp_add:Nn \l_hobby_tempa_fp {\c_pi_fp}
    }
    {}
    \prop_put:Nnx \l_hobby_psi_prop {##1}{\fp_to_tl:N \l_hobby_tempa_fp}
  }
%    \end{macrocode}
%
% Next, we generate the matrix.
% We start with the subdiagonal.
% This is indexed from \(1\) to \(n-1\).
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_put:Nnx \l_hobby_tria_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
  }
%    \end{macrocode}
%
% Next, we attack main diagonal.
% We might need to adjust the first and last terms, but we'll do that in a minute.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {3}
  \fp_sub:Nn \l_hobby_tempa_fp {1}

  \prop_get:NnN \l_hobby_tensionout_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \prop_put:Nnx \l_hobby_trib_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Next, the superdiagonal.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 2} {
  \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_put:Nnx \l_hobby_tric_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Lastly (before the adjustments), the target vector.
%    \begin{macrocode}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 2} {
  \exp_args:NNx \prop_get:NnN \l_hobby_psi_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_tensionout_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_neg:N \l_hobby_tempa_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_psi_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_tensionin_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \prop_put:Nnx \l_hobby_trid_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Next, there are some adjustments at the ends.
% These differ depending on whether the path is open or closed.
%    \begin{macrocode}
\bool_if:NTF \l_hobby_closed_bool {
%    \end{macrocode}
% Closed path
%    \begin{macrocode}
\exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
\fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
\exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
\fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
\exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
\fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
\fp_neg:N \l_hobby_tempa_fp
\prop_put:Nnx \l_hobby_tric_prop {0} {\fp_to_tl:N \l_hobby_tempa_fp}

\prop_put:Nnn \l_hobby_trib_prop {0} {1}
\prop_put:Nnn \l_hobby_trid_prop {0} {0}

\exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
\fp_add:Nn \l_hobby_tempa_fp {1}
\exp_args:NNx \prop_put:Nnx \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}

  \prop_get:NnN \l_hobby_psi_prop {1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_neg:N \l_hobby_tempa_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_psi_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int -1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \exp_args:NNx \prop_put:Nnx \l_hobby_trid_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}
%    \end{macrocode}
% We also need to populate the \(u\)-vector
%    \begin{macrocode}
  \prop_put:Nnn \l_hobby_triu_prop {0} {1}
  \exp_args:NNx \prop_put:Nnn \l_hobby_triu_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {1}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 2} {
  \prop_put:Nnn \l_hobby_triu_prop {##1} {0}
  }
%    \end{macrocode}
% And define the significant entry in the \(v\)-vector.
%    \begin{macrocode}
\exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -1}} \l_tmpa_tl
\fp_set:Nn \l_hobby_triv_fp {\l_tmpa_tl}
\fp_mul:Nn \l_hobby_triv_fp {\l_tmpa_tl}
\exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -2}} \l_tmpa_tl
\fp_mul:Nn \l_hobby_triv_fp {\l_tmpa_tl}
\exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int -2}} \l_tmpa_tl
\fp_mul:Nn \l_hobby_triv_fp {\l_tmpa_tl}
}
{
%    \end{macrocode}
% Open path
% First, we test to see if \(\theta_0\) has been specified.
%    \begin{macrocode}
\fp_if_undefined:NTF \l_hobby_inang_fp
{
  \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_incurl_fp}

  \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}
  
  \prop_put:Nnx \l_hobby_trib_prop {0}  {\fp_to_tl:N \l_hobby_tempa_fp}

  \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_get:NnN \l_hobby_tensionout_prop {0} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \prop_get:NnN \l_hobby_tensionin_prop {1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempb_fp {\l_hobby_incurl_fp}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}
  
  \prop_put:Nnx \l_hobby_tric_prop {0} {\fp_to_tl:N \l_hobby_tempa_fp}

  \fp_neg:N \l_hobby_tempa_fp

  \prop_get:NnN \l_hobby_psi_prop {1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  
  \prop_put:Nnx \l_hobby_trid_prop {0} {\fp_to_tl:N \l_hobby_tempa_fp}
  
}
{
  \prop_put:Nnn \l_hobby_trib_prop {0} {1}
  \prop_put:Nnn \l_hobby_tric_prop {0} {0}
  \prop_put:Nnx \l_hobby_trid_prop {0} {\fp_to_tl:N \l_hobby_inang_fp}
}
%    \end{macrocode}
%
% Next, if \(\psi_n\) has been given.
%    \begin{macrocode}
\fp_if_undefined:NTF \l_hobby_outang_fp
{
  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n     {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempb_fp {\l_hobby_outcurl_fp}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int } \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempb_fp {\l_hobby_tempc_fp}

  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempc_fp {\l_hobby_outcurl_fp}

  \fp_add:Nn \l_hobby_tempb_fp {\l_hobby_tempc_fp}

  \fp_div:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \fp_neg:N \l_hobby_tempa_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl

  \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_put:Nnx \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}


  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_psi_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_neg:N \l_hobby_tempb_fp

  \exp_args:NNx \prop_put:Nnx \l_hobby_trid_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempb_fp}
}
{
  \fp_set_eq:NN \l_hobby_tempa_fp \l_hobby_outang_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_in - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_neg:N \l_hobby_tempa_fp

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_psi_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \exp_args:NNx \prop_put:Nnx \l_hobby_trid_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
% End of adjustments for open paths.
%    \begin{macrocode}
}
%    \end{macrocode}
%
% Now we have the tridiagonal matrix in place, we implement the solution.
%
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trib_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tric_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tria_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempb_fp {\l_hobby_tempa_fp}

  \prop_put:Nnx \l_hobby_trib_prop {##1} {\fp_to_tl:N \l_hobby_tempb_fp}

  \int_compare:nTF {##1 < \l_hobby_npoints_int - 1} {

  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tric_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \prop_put:Nnx \l_hobby_tric_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
  }
  {}

  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trid_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_trid_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tria_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempb_fp {\l_hobby_tempa_fp}

  \prop_put:Nnx \l_hobby_trid_prop {##1} {\fp_to_tl:N \l_hobby_tempb_fp}

  \bool_if:NTF \l_hobby_closed_bool {
  \exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_triu_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_triu_prop {\int_eval:n{##1 - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tria_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_sub:Nn \l_hobby_tempb_fp {\l_hobby_tempa_fp}

  \prop_put:Nnx \l_hobby_triu_prop {##1} {\fp_to_tl:N \l_hobby_tempb_fp}
  }{}
}

\exp_args:NNx \prop_get:NnN \l_hobby_trid_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_div:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_put:Nnx \l_hobby_theta_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}

\bool_if:NTF \l_hobby_closed_bool {
  \exp_args:NNx \prop_get:NnN \l_hobby_triu_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_get:NnN \l_hobby_trib_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_div:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_put:Nnx \l_hobby_triu_prop {\int_eval:n {\l_hobby_npoints_int - 1}} {\fp_to_tl:N \l_hobby_tempa_fp}


}{}

\prg_stepwise_inline:nnnn {\l_hobby_npoints_int - 2} {-1} {0} {
  \exp_args:NNx \prop_get:NnN \l_hobby_theta_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tric_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trid_prop {##1} \l_tmpa_tl
  \fp_neg:N \l_hobby_tempa_fp
  \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trib_prop {##1} \l_tmpa_tl
  \fp_div:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_put:Nnx \l_hobby_theta_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
\bool_if:NTF \l_hobby_closed_bool {
%    \end{macrocode}
% On a closed path, we also need to work out \(M^{-1} u\).
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {\l_hobby_npoints_int - 2} {-1} {0} {
  \exp_args:NNx \prop_get:NnN \l_hobby_triu_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_tric_prop {##1} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_triu_prop {##1} \l_tmpa_tl
  \fp_neg:N \l_hobby_tempa_fp
  \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_trib_prop {##1} \l_tmpa_tl
  \fp_div:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_put:Nnx \l_hobby_triu_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
% Then we compute \(v^\top M^{-1}u\) and \(v^\top M^{-1} \theta\).
% As \(v\) has a particularly simple form, these inner products are easy to compute.
%    \begin{macrocode}
\prop_get:NnN \l_hobby_triu_prop {1} \l_tmpa_tl
\fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
\fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_triv_fp}
\exp_args:NNx \prop_get:NnN \l_hobby_triu_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_sub:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
\fp_add:Nn \l_hobby_tempa_fp {1}

\prop_get:NnN \l_hobby_theta_prop {1} \l_tmpa_tl
\fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
\fp_mul:Nn \l_hobby_tempb_fp {\l_hobby_triv_fp}
\exp_args:NNx \prop_get:NnN \l_hobby_theta_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
\fp_sub:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
\fp_div:Nn \l_hobby_tempb_fp {\l_hobby_tempa_fp}

\prg_stepwise_inline:nnnn {0} {1} {\l_hobby_npoints_int - 1} {
  \prop_get:NnN \l_hobby_triu_prop {##1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}
  \fp_neg:N \l_hobby_tempa_fp
  \prop_get:NnN \l_hobby_theta_prop {##1} \l_tmpa_tl
  \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \prop_put:Nnx \l_hobby_theta_prop {##1} {\fp_use:N \l_hobby_tempa_fp}
}
}{}
%    \end{macrocode}
%
% Now that we have computed the \(\theta_i\)s, we can quickly compute the \(\phi_i\)s.
%
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int - 1} {
    \prop_get:NnN \l_hobby_theta_prop {##1} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_psi_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
    \fp_neg:N \l_hobby_tempa_fp
    \prop_put:Nnx \l_hobby_phi_prop {##1} {\fp_to_tl:N \l_hobby_tempa_fp}
  }
%    \end{macrocode}
%
% If the path is open, this works for all except \(\psi_n\).
% If the path is closed, we can drop our added point.
% Cheaply, of course.
%    \begin{macrocode}
\bool_if:NTF \l_hobby_closed_bool {
\int_decr:N \l_hobby_npoints_int
}{
  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {3}
  \fp_sub:Nn \l_hobby_tempa_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n     {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempa_fp {\l_hobby_outcurl_fp}

  \exp_args:NNo \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int } \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \fp_add:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int -2}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {3}
  \fp_sub:Nn \l_hobby_tempb_fp {1}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int} \l_tmpa_tl
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

  \exp_args:NNx \prop_get:NnN \l_hobby_tensionout_prop {\int_eval:n {\l_hobby_npoints_int - 1}} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}

  \fp_mul:Nn \l_hobby_tempc_fp {\l_hobby_outcurl_fp}

  \fp_add:Nn \l_hobby_tempb_fp {\l_hobby_tempc_fp}

  \fp_div:Nn \l_hobby_tempa_fp {\l_hobby_tempb_fp}

\exp_args:NNx \prop_get:NnN \l_hobby_theta_prop {\int_eval:n {\l_hobby_npoints_int -1}} \l_tmpa_tl
\fp_mul:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

\exp_args:NNx \prop_put:Nnx \l_hobby_phi_prop {\int_use:N \l_hobby_npoints_int} {\fp_to_tl:N \l_hobby_tempa_fp}
}
%    \end{macrocode}
%
% Next task is to compute the \(\rho_i\) and \(\sigma_i\).
%    \begin{macrocode}
\prg_stepwise_inline:nnnn {0} {1} {\l_hobby_npoints_int - 1} {

  \prop_get:NnN \l_hobby_theta_prop {##1} \l_tmpa_tl
  \fp_set:Nn \l_hobby_tempa_fp {\l_tmpa_tl}

    \exp_args:NNx \prop_get:NnN \l_hobby_phi_prop {\int_eval:n {##1 + 1}} \l_tmpa_tl
  
    \fp_set:Nn \l_hobby_tempb_fp {\l_tmpa_tl}

    \fp_set:Nn \l_hobby_temps_fp {0}

    \fp_cos:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_cos:Nn \l_hobby_tempd_fp {\l_hobby_tempb_fp}

    \fp_set_eq:NN \l_hobby_temps_fp \l_hobby_tempc_fp
    \fp_sub:Nn \l_hobby_temps_fp {\l_hobby_tempd_fp}

    \fp_sin:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempb_fp}

    \fp_mul:Nn \l_hobby_tempc_fp {\g_hobby_paramb_fp}
    \fp_sub:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}
    \fp_mul:Nn \l_hobby_temps_fp {\l_hobby_tempd_fp}

    \fp_sin:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempb_fp}

    \fp_mul:Nn \l_hobby_tempd_fp {\g_hobby_paramb_fp}
    \fp_sub:Nn \l_hobby_tempc_fp {\l_hobby_tempd_fp}
    \fp_mul:Nn \l_hobby_temps_fp {\l_hobby_tempc_fp}

    \fp_mul:Nn \l_hobby_temps_fp {\g_hobby_parama_fp}

    \fp_cos:Nn \l_hobby_tempa_fp {\l_hobby_tempa_fp}
    \fp_cos:Nn \l_hobby_tempb_fp {\l_hobby_tempb_fp}

    \fp_set_eq:NN \l_hobby_tempc_fp \l_hobby_tempa_fp
    \fp_sub:Nn \l_hobby_tempc_fp {\l_hobby_tempb_fp}
    \fp_mul:Nn \l_hobby_tempc_fp {\g_hobby_paramc_fp}

    \fp_add:Nn \l_hobby_tempc_fp {\l_hobby_tempb_fp}
    \fp_add:Nn \l_hobby_tempc_fp {1}

    \fp_set_eq:NN \l_hobby_tempd_fp \l_hobby_temps_fp

    \fp_neg:N \l_hobby_tempd_fp
    \fp_add:Nn \l_hobby_tempd_fp {2}

    \fp_div:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}

  \exp_args:NNx \prop_put:Nnx \l_hobby_sigma_prop {\int_eval:n{##1 + 1}} {\fp_to_tl:N \l_hobby_tempd_fp}

    \fp_set_eq:NN \l_hobby_tempc_fp \l_hobby_tempa_fp
    \fp_sub:Nn \l_hobby_tempc_fp {\l_hobby_tempb_fp}
    \fp_mul:Nn \l_hobby_tempc_fp {\g_hobby_paramc_fp}
    \fp_neg:N \l_hobby_tempc_fp

    \fp_add:Nn \l_hobby_tempc_fp {\l_hobby_tempa_fp}
    \fp_add:Nn \l_hobby_tempc_fp {1}

    \fp_set_eq:NN \l_hobby_tempd_fp \l_hobby_temps_fp

    \fp_add:Nn \l_hobby_tempd_fp {2}

    \fp_div:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}

   \prop_put:Nnx \l_hobby_rho_prop {##1} {\fp_to_tl:N \l_hobby_tempd_fp}

  }

\prg_stepwise_inline:nnnn {0} {1} {\l_hobby_npoints_int - 1} {
    \prop_get:NnN \l_hobby_angles_prop {##1} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_theta_prop {##1} \l_tmpa_tl
    \fp_sub:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}
    \fp_cos:Nn \l_hobby_tempc_fp {\l_hobby_tempc_fp}
    \prop_get:NnN \l_hobby_rho_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_distances_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_div:Nn \l_hobby_tempd_fp {3}
    \fp_div:Nn \l_hobby_tempc_fp {3}
  \prop_get:NnN \l_hobby_pointsx_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_pointsy_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
  \exp_args:NNx \prop_put:Nnx \l_hobby_controla_prop {\int_eval:n {##1 + 1}} {x = \fp_use:N \l_hobby_tempc_fp, y = \fp_use:N \l_hobby_tempd_fp }
  }

\prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int} {
    \exp_args:NNx \prop_get:NnN \l_hobby_angles_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
    \fp_set:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
  \prop_get:NnN \l_hobby_phi_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_sin:Nn \l_hobby_tempd_fp {\l_hobby_tempc_fp}
    \fp_cos:Nn \l_hobby_tempc_fp {\l_hobby_tempc_fp}
    \fp_neg:N \l_hobby_tempc_fp
    \fp_neg:N \l_hobby_tempd_fp
    \prop_get:NnN \l_hobby_sigma_prop {##1} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \exp_args:NNx \prop_get:NnN \l_hobby_distances_prop {\int_eval:n {##1 - 1}} \l_tmpa_tl
    \fp_mul:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \fp_mul:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \fp_div:Nn \l_hobby_tempc_fp {3}
    \fp_div:Nn \l_hobby_tempd_fp {3}
    \prop_get:NnN \l_hobby_pointsx_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempc_fp {\l_tmpa_tl}
    \prop_get:NnN \l_hobby_pointsy_prop {##1} \l_tmpa_tl
    \fp_add:Nn \l_hobby_tempd_fp {\l_tmpa_tl}
    \prop_put:Nnx \l_hobby_controlb_prop {##1} {x = \fp_use:N \l_hobby_tempc_fp, y = \fp_use:N \l_hobby_tempd_fp }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbyinit}
% Initialise the settings for Hobby's algorithm
%    \begin{macrocode}
\NewDocumentCommand \hobbyinit {m m m} {
\hobby_set_cmds:nnn#1#2#3
\prop_clear:N \l_hobby_points_prop
\prop_clear:N \l_hobby_pointsx_prop
\prop_clear:N \l_hobby_pointsy_prop
\prop_clear:N \l_hobby_angles_prop
\prop_clear:N \l_hobby_distances_prop
\prop_clear:N \l_hobby_tensionout_prop
\prop_clear:N \l_hobby_tensionin_prop
\prop_clear:N \l_hobby_tria_prop
\prop_clear:N \l_hobby_trib_prop
\prop_clear:N \l_hobby_tric_prop
\prop_clear:N \l_hobby_trid_prop
\prop_clear:N \l_hobby_triu_prop
\prop_clear:N \l_hobby_psi_prop
\prop_clear:N \l_hobby_theta_prop
\prop_clear:N \l_hobby_phi_prop
\prop_clear:N \l_hobby_sigma_prop
\prop_clear:N \l_hobby_rho_prop
\prop_clear:N \l_hobby_controla_prop
\prop_clear:N \l_hobby_controlb_prop

  \int_set:Nn \l_hobby_npoints_int {-1}
  \fp_set_eq:NN \l_hobby_inang_fp \c_undefined_fp
  \fp_set_eq:NN \l_hobby_outang_fp \c_undefined_fp
  \fp_set_eq:NN \l_hobby_incurl_fp \c_one_fp
  \fp_set_eq:NN \l_hobby_outcurl_fp \c_one_fp
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbyaddpoint}
%    \begin{macrocode}
\NewDocumentCommand \hobbyaddpoint { m } {
    \keys_set:nn { hobby/read in all }
    {
      tension~out,
      tension~in,
      #1
    }
    \int_incr:N \l_hobby_npoints_int
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionout_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempc_fp}
    \exp_args:NNo \prop_put:Nnx \l_hobby_tensionin_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempd_fp}
    \exp_args:NNo \prop_put:Nnx \l_hobby_points_prop {\int_use:N \l_hobby_npoints_int } {x = \fp_use:N \l_hobby_tempa_fp, y = \fp_use:N \l_hobby_tempb_fp }
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsx_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempa_fp}
    \exp_args:NNo \prop_put:Nnx \l_hobby_pointsy_prop {\int_use:N \l_hobby_npoints_int } {\fp_to_tl:N \l_hobby_tempb_fp}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbysetparams}
%    \begin{macrocode}
\NewDocumentCommand \hobbysetparams { m } {
  \keys_set:nn { hobby / read in params }
  {
    #1
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobbygenpath}
%    \begin{macrocode}
\cs_new:Nn \hobby_set_cmds:nnn {
  \cs_set_eq:NN \hobby_moveto:n #1
  \cs_set_eq:NN \hobby_curveto:nnn #2
  \cs_set_eq:NN \hobby_close:n #3
}
\tl_new:N \l_tmpc_tl
\NewDocumentCommand \hobbygenpath { } {
  \hobby_genpath:
  \prop_get:NnN \l_hobby_points_prop {0} \l_tmpa_tl
  \exp_args:No \hobby_moveto:n {\l_tmpa_tl}
  \prg_stepwise_inline:nnnn {1} {1} {\l_hobby_npoints_int} {
    \prop_get:NnN \l_hobby_controla_prop {##1} \l_tmpa_tl
    \prop_get:NnN \l_hobby_controlb_prop {##1} \l_tmpb_tl
    \prop_get:NnN \l_hobby_points_prop {##1} \l_tmpc_tl
    \exp_args:Nooo \hobby_curveto:nnn {\l_tmpa_tl} {\l_tmpb_tl} {\l_tmpc_tl}
}
  \bool_if:NTF \l_hobby_closed_bool {
    \prop_get:NnN \l_hobby_points_prop {0} \l_tmpa_tl
    \exp_args:No \hobby_close:n {\l_tmpa_tl}
    }{}
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\ExplSyntaxOff
%    \end{macrocode}
% \iffalse
%</hobby>
% \fi
%
% \subsection{PGF Library}
%
% \iffalse
%<*pgflibrary>
% \fi
% 
%    \begin{macrocode}
\input{hobby.code.tex}

\pgfkeys{
  /pgf/hobby/.is family,
  /pgf/hobby/.cd,
  x/.code={\pgf@x=#1cm},
  y/.code={\pgf@y=#1cm},
}

\def\hobby@curveto#1#2#3{%
  \pgfpathcurveto{\hobby@topgf{#1}}{\hobby@topgf{#2}}{\hobby@topgf{#3}}%
}

\def\hobby@topgf#1{%
    \pgfqkeys{/pgf/hobby}{#1}%
}

\def\hobby@close#1{%
  \pgfpathclose
}

%    \end{macrocode}
% \iffalse
%</pgflibrary>
% \fi
%
% \subsection{TikZ Library}
%
% \iffalse
%<*tikzlibrary>
% \fi
% 
%    \begin{macrocode}
%
\usepgflibrary{hobby}

\let\hobby@opts=\pgfutil@empty

\tikzset{
  curve through/.style={
    to path={
      \pgfextra{
        \expandafter\curvethrough\expandafter[\hobby@opts]{(\tikztostart) .. #1 .. (\tikztotarget)}
      }
    }
  },
  tension in/.code = {},
  tension out/.code = {},
  closed/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts closed=#1}%
  },
  closed/.default = true,
  in angle/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts in       angle=#1,}%
  },
  out angle/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts out angle=#1,}%
  },
  in curl/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts in curl=#1,}%
  },
  out curl/.code = {%
    \expandafter\def\expandafter\hobby@opts\expandafter{\hobby@opts out curl=#1,}%
  },
}
%    \end{macrocode}
% \begin{macro}{\curvethrough}
%    \begin{macrocode}
\newcommand\curvethrough[2][]{%
  \hobbyinit\pgfutil@gobble\hobby@curveto\hobby@close
  \hobbysetparams{#1}%
  \hobby@processpts{#2}%
}

\newcommand\hobby@processpts[1]{%
  \pgfutil@in@{..}{#1}%
  \ifpgfutil@in@%
    \hobby@getonepoint #1 \relax
    \let\hobby@next=\hobby@processpts
  \else
    \def\hobby@pt{#1}%
    \def\hobby@rest{}%
    \let\hobby@next=\hobbygenpath
  \fi
  \let\tikz@scan@point@options=\pgfutil@empty
  \expandafter\tikz@scan@one@point\expandafter\pgfutil@firstofone\hobby@pt\relax
  \pgfmathsetmacro\hobby@x{\the\pgf@x/1cm}%
  \pgfmathsetmacro\hobby@y{\the\pgf@y/1cm}%
  \expandafter\hobbyaddpoint\expandafter{\tikz@scan@point@options,x = \hobby@x, y = \hobby@y}%
  \expandafter\hobby@next\expandafter{\hobby@rest}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\hobby@onepoint}
%    \begin{macrocode}
\def\hobby@getonepoint#1..#2\relax{%
  \def\hobby@pt{#1}%
  \def\hobby@rest{#2}%
}

\def\tikz@curveto@auto{%
  \hobbyinit\pgfutil@gobble\hobby@curveto\hobby@close
  \pgfmathsetmacro\hobby@x{\the\tikz@lastx/1cm}%
  \pgfmathsetmacro\hobby@y{\the\tikz@lasty/1cm}%
  \pgfutil@ifundefined{tikz@scan@point@options}{%
    \hobbyaddpoint{x = \hobby@x, y = \hobby@y}%
  }{%
  \expandafter\hobbyaddpoint\expandafter{\tikz@scan@point@options,x = \hobby@x, y = \hobby@y}%
  }%
  \let\tikz@scan@point@options=\pgfutil@empty
  \tikz@scan@one@point\hobby@addfromtikz}

\def\hobby@addfromtikz#1{%
  #1%
  \tikz@make@last@position{#1}%
  \pgfmathsetmacro\hobby@x{\the\pgf@x/1cm}%
  \pgfmathsetmacro\hobby@y{\the\pgf@y/1cm}%
  \expandafter\hobbyaddpoint\expandafter{\tikz@scan@point@options,x = \hobby@x, y = \hobby@y}%
  \hobby@donext}

\def\hobby@donext{%
  \pgfutil@ifnextchar.%
  {\hobby@curveto@auto}%
  {\hobby@finish@auto}}%

\def\hobby@curveto@auto..{%
  \pgfutil@ifnextchar c%
  {\hobby@finish@auto ..}%
  {\hobby@curveto@continue}}%

\def\hobby@curveto@continue{%
  \let\tikz@scan@point@options=\pgfutil@empty
  \tikz@scan@one@point\hobby@addfromtikz}

\def\hobby@finish@auto{%
  \hobbygenpath
  \tikz@scan@next@command%
}
%    \end{macrocode}
% \end{macro}
% \iffalse
%</tikzlibrary>
% \fi
%
%\Finale